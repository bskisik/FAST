{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FAST User Guide","text":""},{"location":"#welcome-to-fasts-documentation","title":"Welcome to FAST's documentation","text":"<p>FAST is an end-to-end and unsupervised earthquake detection pipeline. It is a useful tool for seismologists to extract more small earthquakes from continuous seismic data.</p>"},{"location":"#github-development-page","title":"Github development page:","text":"<p>https://github.com/stanford-futuredata/FAST</p>"},{"location":"#contents","title":"Contents","text":"<ol> <li> <p>FAST Overview. Click here for a summary of the FAST algorithm and why you might want to use it on your seismic data.</p> </li> <li> <p>Install Go here to learn how to install and run the FAST software on your computer.</p> <ol> <li> <p>Google Colab</p> </li> <li> <p>Linux</p> </li> <li> <p>Docker</p> </li> </ol> </li> <li> <p>Tutorial Learn how FAST detects earthquakes on the Hector Mine data set.</p> </li> <li> <p>How to Set Parameters Click here to learn how to test FAST on your own data sets.</p> <ol> <li> <p>FAST Checklist</p> </li> <li> <p>Getting Seismic Data</p> </li> <li> <p>Input and Preprocessing</p> </li> <li> <p>Fingerprint</p> </li> <li> <p>Similarity Search</p> </li> <li> <p>Network Detection </p> </li> <li> <p>FAST Output </p> </li> <li> <p>Phase Picking </p> </li> <li> <p>Earthquake Location </p> </li> <li> <p>Example Parameters Click here to see data sets FAST has been used on to detect earthquakes.</p> </li> </ol> </li> <li> <p>References Read publications about FAST here.</p> </li> </ol>"},{"location":"FAST_checklist/","title":"Checklist for running FAST on Your Own Dataset","text":"<p>Info</p> <p>Follow along with the tutorial section to make sure you follow the correct steps for FAST while using your own dataset.  </p> <p>In most cases, if something does not run correctly, there is likely an issue with the file path or file name that users must fix.</p> <ul> <li>Follow install instructions: Google Colab, Linux, or Docker</li> <li>Get seismic data</li> <li>Put seismic data folder in <code>~/FAST/data/</code></li> <li>Plot sample spectrograms to decided decimate factor and min/max frequency. Python script found in <code>~/FAST/utils/preprocess</code>: <code>plot_sample_spectrograms.py</code></li> </ul> <p></p> <ul> <li>Check sampling rate of waveform data for decimate value</li> </ul> <pre><code>&gt;&gt;&gt; st = read(\u201cAZ.TONN*\u201c)\n&gt;&gt;&gt; print(st)\n3 Trace(s) in Stream:\nAZ.TONN..HNE | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples\nAZ.TONN..HNN | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples\nAZ.TONN..HNZ | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples\n</code></pre> <pre><code>&gt;&gt;&gt; st = read(\u201cCI.CRR*\u201c)\n&gt;&gt;&gt; print(st)\n3 Trace(s) in Stream:\nCI.CRR..HHE | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples\nCI.CRR..HHN | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples\nCI.CRR..HHZ | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples\n</code></pre> <ul> <li> <p>Choose sampling rate for fingerprinting:  </p> <ul> <li>If chosen sampling rate is 25 Hz, and trace sampling rate is 200 Hz, choose a decimate factor of 8</li> <li>If chosen sampling rate is 25 Hz, and trace sampling rate is 100 Hz, choose a decimate factor of 4  </li> </ul> </li> <li> <p>Use <code>~/FAST/utils/preprocess/bandpass_filter_decimate.py</code> and create a bash script similar to <code>~/FAST/utils/preprocess/mdl_bandpass_filter.sh</code> to filter waveforms. Make sure to change input directory and consider creating an output directory for the decimated waveform files.  </p> </li> </ul> <p>Change input directory in  <code>~/FAST/utils/preprocess/bandpass_filter_decimate.py</code> </p> <pre><code>ts_dir = '/lfs/1/ceyoon/TimeSeries/NEP/waveforms'+station+'/' # change input directory to reference where your waveforms are\nout_dir = '../../data/waveforms_decimated/' # consider creating an output directory \nif not os.path.exists(out_dir): # create directory if it doesn't exist\nos.mkdir(out_dir)\n</code></pre> <p>Change where output files are written</p> <pre><code>st.write(ts_dir+str_prefix+file_str, format=format_str) # change ts_dir to out_dir\n</code></pre> <pre><code>&gt;&gt;&gt; st = read(\u201cAZ.TONN*\u201c)\n&gt;&gt;&gt; print(st)\n3 Trace(s) in Stream:\nAZ.TONN..HNE | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples\nAZ.TONN..HNN | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples\nAZ.TONN..HNZ | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples\n</code></pre> <p>The above waveform is 200 Hz, so the decimate factor should be 8, for the FAST fingerprint sampling rate to be 25 Hz:  </p> <pre><code>python bandpass_filter_decimate.py AZ TONN HNZ 4 12 8\n\n# 4: min frequency\n# 12: max frequency\n# 8: decimate value\n</code></pre> <p>4 - 12 Hz is a good general min/max frequency range for most waveform files. The decimate value depends on the sampling rate. Follow the guide above to choose this value.</p> <ul> <li>Create fingerprint input json files for each channel at each station in your dataset. Example:  </li> </ul> <pre><code>{\n    \"fingerprint\": {\n        \"sampling_rate\": 25, # final sampling rate after decimating\n        \"min_freq\": 4.0,\n        \"max_freq\": 12.0,\n        \"spec_length\": 6.0,\n        \"spec_lag\": 0.12,\n        \"fp_length\": 64,\n        \"fp_lag\": 10,\n        \"k_coef\": 400,\n        \"nfreq\": 32,\n        \"mad_sampling_rate\": 1,\n        \"mad_sample_interval\": 86400\n    },\n\n    \"performance\": {\n        \"num_fp_thread\": 16,\n        \"partition_len\": 86400\n    },\n\n    \"data\": {\n        \"station\": \"WLA06\",\n        \"channel\": \"HNE\",\n        \"start_time\": \"21-06-05T00:00:00.0\",\n        \"end_time\": \"21-06-06T00:00:00.0\",\n        \"folder\": \"data/waveforms/\", # folder where decimated waveform files are located\n        \"fingerprint_files\": [\n        \"Deci4.bp2to20.YR.ED04..HHZ.D.2016.303\"],\n        \"MAD_sample_files\": [\n        \"Deci4.bp2to20.YR.ED04..HHZ.D.2016.303\"]\n    }\n}\n</code></pre> <ul> <li>Put all fp_input_NETWORK_STATION_CHANNEL.json files in <code>~/FAST/config.json</code> and <code>~/FAST/parameters/fingerprint/your_dataset_folder/global_indices.json</code>; Example:    </li> </ul> <pre><code>{\n    \"index_folder\": \"../data/global_indices/\",\n    \"fp_param_dir\": \"../parameters/fingerprint/your_dataset_folder/\", # fp_input_NETWORK_STATION_CHANNEL.json directory\n    \"fp_params\": [\"fp_input_CI_TPC_EHZ.json\", \"fp_input_CI_RMR_EHZ.json\", \"fp_input_CI_RMM_EHZ.json\",\n        \"fp_input_CI_HEC_BHE.json\", \"fp_input_CI_HEC_BHN.json\", \"fp_input_CI_HEC_BHZ.json\",\n        \"fp_input_CI_CPM_EHZ.json\", \"fp_input_CI_GTM_EHZ.json\", \"fp_input_CI_CDY_EHZ.json\"]\n}\n</code></pre> <ul> <li> <p>After your data is ready, you can begin fingerprinting.  </p> </li> <li> <p>Make sure your <code>fp_input_NETWORK_STATION_CHANNEL.json</code> files are pointing to the correct decimated waveform files and directory otherwise FAST will not write to global index.</p> </li> <li> <p>Fingerprinting is complete when you see: </p> </li> <li> <p>If you get an error when FAST tries to write global index, check <code>global_indices.json</code> to make sure there are not any disceprencies between <code>config.json</code> and <code>globali_indices.sjon</code>, such as a station being included in <code>config.json</code> but left out of <code>global_indices.json</code></p> </li> <li> <p>Now you can begin similarity search </p> </li> <li> <p>Create an <code>output_Dataset_pairs.sh</code> script similar to <code>~/FAST/parameters/postprocess/output_HectorMine_pairs.sh</code> for your dataset.  </p> </li> <li> <p>Create an <code>combine_Dataset_pairs.sh</code> script similar to <code>~/FAST/parameters/postprocess/combine_HectorMine_pairs.sh</code> for your dataset.  </p> </li> <li> <p>Follow instructions for running <code>output_Dataset_pairs.sh</code> and <code>combine_Dataset_pairs.sh</code> in Tutorial.  </p> </li> <li> <p>If a station and its channels are stuck when merging files while running <code>combine_Dataset_pairs.sh</code>, remove it from <code>output_Dataset_pairs.sh</code>. Rerun <code>output_Dataset_pairs.sh</code> then <code>combine_Dataset_pairs.sh</code>.  </p> </li> <li> <p>Configure parameters in <code>~/FAST/parameters/postprocess/7sta_2stathresh_network_params.json</code> for your dataset. Change the 7 in the file name to the number of stations in your dataset.</p> </li> <li> <p>Run <code>python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json</code></p> </li> <li> <p>Clean up results:  </p> <ul> <li>Change file path in <code>arrange_network_detection_results.py</code> if you changed the file name of <code>7sta_2stathresh_network_params.json</code></li> <li>Change <code>nsta</code> to number of stations in your dataset in <code>arrange_network_detection_results.py</code> and <code>n_sta</code> in  <code>delete_overlap_network_detections.py</code> </li> <li>Also change file path name in <code>remove_duplicates_after_network.sh</code>, <code>delete_overlap_network_detections.py</code>, and <code>final_network_sort_nsta_peaksum.sh</code> </li> </ul> </li> </ul> <pre><code>~/FAST$ cd utils/network/\n~/FAST/utils/network$ python arrange_network_detection_results.py\n~/FAST/utils/network$ ./remove_duplicates_after_network.sh\n~/FAST/utils/network$ python delete_overlap_network_detections.py\n~/FAST/utils/network$ ./final_network_sort_nsta_peaksum.sh\n</code></pre> <ul> <li> <p>Continue with next steps in tutorial  </p> </li> <li> <p>Plot detected earthquakes (change file paths in <code>PARTIALplot_detected_waveforms_HectorMine.py</code>):  </p> </li> </ul> <p><pre><code>[det_start_ind, det_end_ind, dL, nevents, nsta, tot_ndets, max_ndets, tot_vol, max_vol, peaksum, num_sta, diff_ind] = np.loadtxt(times_dir+'sort_nsta_peaksum_6sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt', usecols=(0,1,2,3,4,5,6,7,8,9,10,11), unpack=True) # change file name\nout_dir = times_dir+'6sta_2stathresh_NetworkWaveformPlots/' # change file name\n</code></pre> * Change start time  </p> <pre><code>init_time = UTCDateTime('2021-06-05T00:00:00.00') # global start time for all channels\n</code></pre> <ul> <li>Change directory for waveform files and change format if different  </li> </ul> <pre><code>st = read(ts_dir+'waveforms_priority_BP/Deci*', format='MSEED') \n</code></pre> <p>(Steps in tutorial) <pre><code>~/FAST/utils/network$ cd ..\n~/FAST/utils$ cd events/\n~/FAST/utils/events$ python PARTIALplot_detected_waveforms_HectorMine.py 0 100\n</code></pre></p> <ul> <li> <p>Continue with next step of setting threshold  </p> </li> <li> <p>Make changes to <code>output_final_detection_list.py</code>:  </p> </li> </ul> <pre><code>infile_name = 'EQ_sort_nsta_peaksum_6sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt'\noutfile_name = times_dir+'FINAL_Detection_List_HectorMine_6sta_2stathresh.txt'\ninit_time = UTCDateTime('2021-06-05T00:00:00.00') # global start time for all channels\n</code></pre> <p>Now, follow the steps in Phase Picking and Earthquake Location.  </p>"},{"location":"FAST_output/","title":"Output","text":""},{"location":"FAST_output/#network-detection-outputs","title":"Network Detection Outputs","text":"<ul> <li>Event resolution: final step after pseudo-association<ul> <li>Pairs of similar fingerprints --&gt; list of event detections  </li> </ul> </li> <li>Network Detection Output (text file with labeled columns)<ul> <li>Example (ranked in descending order of \u2018peaksum\u2019): <code>7sta_2stathresh_detlist_rank_by_peaksum.txt</code> </li> <li>First (num_sta = number of stations) columns: starting fingerprint index at each station (time information) <ul> <li>Outputs \u201cnan\u201d if not observed at a particular station</li> </ul> </li> <li><code>dL</code>: Maximum length (samples) along diagonal, overall event-pairs containing this event  </li> <li><code>nevents</code>: Number of other events \u2018linked\u2019 to (similar to) this event  </li> <li><code>nsta</code>: Number of stations over which other events are similar to this event  </li> <li><code>tot_ndets</code>: Total number of fingerprint-pairs (pixels) containing this event, overall event-pair clusters, over all stations  </li> <li><code>max_ndets</code>: Maximum number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations</li> <li><code>tot_vol</code>: Totalsum (or \u2018volume\u2019 )of all similarity values (added overall stations), over all event-pairs containing this event  </li> <li><code>max_vol</code>: Maximum sum (or \u2018volume\u2019) of all similarity values (added overall stations), over all event-pairs containing this event  </li> <li><code>max_peaksum</code>: Maximum similarity value (added overall stations), overall event-pairs containing this event  </li> </ul> </li> </ul>"},{"location":"about/","title":"Est non fitque","text":""},{"location":"about/#ruit-tum-ore-super-sed-perstat-rebus","title":"Ruit tum ore super sed perstat rebus","text":"<p>Lorem markdownum innumeras auctor Pergama levis corpore egressa pedem! Sine mihi postibus perenni; somni nulla. Byblis ferae Lycaon gemelliparae videt inspicitur imagine dedit nobis, et clauditur vocem. In ab, ille quippe volat sensi culpa audit utque delicuit videre tulit talis primum, sine.</p> <p>Vulnere et cornua dicere captivarum intravit, ossa Claninque, propago. Ferendum Melaneus minimo, ut extra veri pius: sua per sonat gutture: per usque. Sole terras, spoliataque probabo iustius obstantis solque ardetque Cythereius duro.</p>"},{"location":"about/#sententia-tlepolemus-huius-cui-ferox-cuique-vulgata","title":"Sententia Tlepolemus huius cui ferox cuique vulgata","text":"<p>Nunc signo diu monitusque, cunctis, tum Teucri ulla felix quercum, consorti motu repetitaque? Vulnere grata contigit caeruleas pietas aequore dixit: emerguntque velis corpora voluptas, obruta nec ibat vultus quae.</p> <p>Ventos vires, unus: idem est Lycei impete fulvis. Erat et sed gaudent cruore muris! Hominumque possem; rediere hic moles gemmae tempus huc enim digitoque.</p>"},{"location":"about/#nidos-aliisque-gorgoneas","title":"Nidos aliisque Gorgoneas","text":"<p>Vix spes secutum de indiciumque manu cuiquam status morsibus curvamine in semper mente dum. Et suis Cadmeida exaudi audent ut summa, tendere, more. Magna retexi flexi medio deprenduntur verba, ambarum servasset prohibete Aeson!</p> <ol> <li>Mea esse aliquid faciet numine barbaricoque Delphos</li> <li>Hospitio sacra</li> <li>Quae vos missum quibus enim vellem ligno</li> <li>Iam non alumnus manibus consensistis errat est</li> <li>Fugit patulo communis Triviae nos secreta</li> </ol> <p>Vox adflat qui, iram prius ille iuga altera potentia membris efficient. Umbram aequoris, laeso alto commisit loquaci. Responsaque aequoreae; rogata eligit labuntur sedes mortales. Temptabat inque.</p> <p>Reget tria ita sensit rebus fretum illic mortalem trahit locuti labori mea clamor vulnera hi obstaret interea? Rictus inmani leves rapiunt forte excidit! Structoque per patria pudore respicit fulmineo iubet cura euntem mea iungi flectitque. Fama rigidique nostraque petii lumina et Thestias te Syron Balearica excutior ne abire sumpserat mihi.</p>"},{"location":"brazil_dataset/","title":"0.9 BrazilAcre Data Set","text":"<ul> <li>Location: Acre, Brazil (search for intermediate-depth and deep earthquakes)  </li> <li>Duration: about 3 months (with time gaps): 2015-05-28 to 2016-02-01  </li> <li>Network: 1 station (Figure 14), 3 components (HHE, HHN, HHZ) = 3 channels. \u2022 Sampling rate: 100 Hz  </li> <li>Provided by: Marcelo de Bianchi (University of Sao Paulo)  </li> </ul> Figure 14: Acre, Brazil map provided by Marcelo de Bianchi: 1 station (yellow triangle) used for FAST detection, and locations of known catalog events (circles colored by depth)."},{"location":"brazil_dataset/#091-preprocessing","title":"0.9.1 Preprocessing","text":"<ul> <li>Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/continuous_data_times_BrazilAcre.sh\n</code></pre> <p>The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_BrazilAcre.py to plot the duration of available continuous data at each station and channel (Figure 15).  </p> <p> </p> Figure 15: Duration of BrazilAcre continuous data at 1 station (3 components). White sections indicate time gaps. <ul> <li>Confirmed no zero-filled time-gap sections of continuous data in all 3 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py\n</code></pre> <p>Use original mseed data files.</p> <ul> <li>Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/sample_spectrograms_BrazilAcre.sh\n</code></pre> <ul> <li>Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/bandpass_filter_decimate_BrazilAcre.sh\n</code></pre> <p>Based on sample spectrograms, filter 3-20 Hz for all 3 channels. Decimate by a factor of 2, to 50 Hz sampling rate. Filtered continuous data files start with Deci2.bp3to20.*, which are input to the fingerprint step.  </p> <ul> <li>Need to add <code>.mseed</code> extension to all time series files, otherwise the Julian day number in the time series file gets removed while fingerprinting, and we cannot tell the difference between fingerprints from different days.  </li> </ul>"},{"location":"brazil_dataset/#092-fingerprint","title":"0.9.2 Fingerprint","text":"<p>Master script to create fingerprints on each channel, then generate global indices at the end:  </p> <pre><code>~/FAST/fingerprint/$ ../parameters/fingerprint/BrazilAcre/run_fp_BrazilAcre.sh\n</code></pre> <p>Example script to generate fingerprints on one channel (HHE) at one station (CZSB), called by the master script run_fp_BrazilAcre.sh:  </p> <pre><code>~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/BrazilAcre/fp_input_BR_CZSB_HHE.json\n    \"fingerprint\": {\n       \"sampling_rate\": 50,\n       \"min_freq\": 3.0,\n       \"max_freq\": 20.0,\n       \"spec_length\": 10.0,\n       \"spec_lag\": 0.2,\n       \"fp_length\": 128,\n         Continuous Data (Network.Station.Channel)\n       \"fp_lag\": 10,\n       \"k_coef\": 800,\n       \"nfreq\": 32,\n       \"mad_sampling_rate\": 0.1,\n       \"mad_sample_interval\": 86400\n    \"data\": {\n       \"station\": \"CZSB\",\n       \"channel\": \"HHE\",\n       \"start_time\": \"15-10-28T00:00:00.0\",\n       \"end_time\": \"16-02-01T00:00:03.0\",\n       \"folder\": \"/lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/\",\n</code></pre> <p>There are a total of 3 <code>fp_input_NETWORK_STATION_CHANNEL.json</code> fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S25.  </p> <p>Table S25: Fingerprint input parameters for BrazilAcre earthquake detection: 3-component at 1 station (Figure 14, yellow triangle), after bandpass filter 3-20 Hz, and decimated to 50 Hz sampling rate. The fingerprint sampling period is dt_fp = 2 seconds.  </p> <p> </p> <p>Median/MAD output files: <code>mad/mad*.txt</code> Fingerprints (binary files): <code>fingerprints/CZSB.HHE.fp</code> Timestamps at each fingerprint index (text files): <code>timestamps/CZSB.HHE.ts</code> </p> <p>Finally, to create global indices for the BrazilAcre data set, so that fingerprint indices from different channels (all 3) and stations are referenced to a common starting time:  </p> <pre><code>$ python global_index.py ../parameters/fingerprint/BrazilAcre/global_indices_BrazilAcre.json\n</code></pre> <p>The common starting time is in global_idx_stats.txt: 2015-10-28T00:00:21.340000 UTC  </p>"},{"location":"brazil_dataset/#093-similarity-search","title":"0.9.3 Similarity Search","text":"<p>Master script to run similarity search on each channel (out of 3 total):  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/run_simsearch_BrazilAcre.sh\n</code></pre> <p>Example script to run similarity search on one channel (HHE) at one station (CZSB), called by the master script <code>run_simsearch_BrazilAcre.sh</code>:  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/filt_simsearch_input_BrazilAcre.sh CZSB HHE\nNTBLS=100\nNHASH=4\nNREPEAT=5\nNVOTES=2\nNTHREAD=56\nNUM_PART=1\n</code></pre> <p>Table S26: Similarity search input parameters for BrazilAcre earthquake detection: 3 channels at 1 station (3 components each).  </p> <p> </p> <p>The same input parameters are used for similarity search on all 3 channels (Table S26).  </p>"},{"location":"brazil_dataset/#094-postprocessing","title":"0.9.4 Postprocessing","text":"<p>First, run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (3 total):  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/output_BrazilAcre_pairs.sh  \n</code></pre> <p>For example, on one channel (HHE) at one station (CZSB), all on one line:  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/\n-p candidate_pairs_CZSB_HHE -i /lfs/1/ceyoon/TimeSeries/BrazilAcre/global_indices/CZSB_HHE_idx_mapping.txt\n</code></pre> <p>Output file for example (large size at channel level): /<code>lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ candidate_pairs_CZSB_HHE_merged.txt</code> </p> <p>Second, run the master script to combine similarity output from all 3 components at a given station, for 1 station:  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/combine_BrazilAcre_pairs.sh\n</code></pre> <p>For example, on three channels (HHE, HHN, HHZ) at one station (CZSB), first move the similarity output text files to the inputs_network/ directory:  </p> <pre><code>$ cd /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/\n$ mv candidate_pairs_CZSB_HH*_merged.txt ../../../inputs_network/\n</code></pre> <p>Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S26). Note: this step will delete the <code>candidate_ pairs_CZSB_HH*_merged.txt</code> files.  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/\n-p candidate_pairs_CZSB --sort true --parse false -c true -t 6\n</code></pre> <p>Output file for example (smaller size at station level): <code>/lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ candidate_pairs_CZSB_combined.txt</code> </p> <p>Finally, detect similar fingerprints across the network of 1 station, using the input parameters in Table S27 (Note: this step only aggregates similar event pairs from similar fingerprints, and resolves the pairs into a list of candidate events, since there is only 1 station.):  </p> <pre><code>~/FAST/postprocessing/$\npython scr_run_network_det.py ../parameters/postprocess/BrazilAcre/1sta_1stathresh_network_params.json\n       \"network\": {\n              \"max_fp\": 4147182,\n              \"dt_fp\": 2.0, (seconds)\n              \"dgapL\": 10, (20 s)\n              \"dgapW\": 3, (6 s)\n              \"num_pass\": 2,\n              \"min_dets\": 3,\n              \"min_sum_multiplier\": 1,\n              \"max_width\": 8, (16 s)\n              \"ivals_thresh\": 6,\n              \"nsta_thresh\": 1,\n              \"input_offset\": 15 (30 s) &lt;--- NOT USED\n},  \n</code></pre> <p>Table S27: Network detection input parameters for BrazilAcre at 1 station. max_fp = 4147182 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 2 seconds is the fingerprint sampling period from Table S25.  </p> <p> </p> <p>Network detection output file: <code>/lfs/1/ceyoon/TimeSeries/BrazilAcre/network_detection/1sta_1stathresh_detlist_rank_by_peaksum.tx</code>t (14,477 events)  </p> <p>At this point, FAST earthquake detection processing is done.  </p>"},{"location":"brazil_dataset/#095-remove-duplicates-after-network-detection","title":"0.9.5 Remove duplicates after network detection","text":"<p>Sort events in descending order of peaksum (peak similarity score between similar fingerprints) for the final detection list.  </p> <pre><code>~/FAST/utils/network/$ ./final_single_station_sort_nsta_peaksum.sh\n</code></pre> <p>Output: <code>sort_peaksum_1sta_1stathresh_CZSB_events.txt</code> (14,477 events)  </p>"},{"location":"brazil_dataset/#096-visual-inspection-and-final-detections","title":"0.9.6 Visual inspection and final detections","text":"<p>Plot event waveforms in the final detection list, ranked in descending order of peaksum (peak similarity score between similar fingerprints), for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (peaksum \u2265 6).  </p> <pre><code>~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_BrazilAcre.py 0 14477\n</code></pre> <p>Output: <code>.png</code> image files in <code>1sta_1stathresh_NetworkWaveformPlots/</code> (zip file)  </p> <p>Visual inspection shows that there are many false detections that do not look like earthquake waveforms (for example, <code>event_rank00000_peaksum116351_ind854248_time1708496.0_2015-11-16T18/35/17.340000.png</code>). However, some earthquake waveforms (for example, <code>event_rank00049_peaksum26898_ind1297608_time2595216</code>. <code>0_2015-11-27T00/53/57.340000.png</code>) are also detected. I suggest running FAST on at least 3 stations for reliable earthquake detection. </p> <p>14,474 events are above the arbitrary low threshold (peaksum \u2265 6).  </p> <ul> <li><code>EQ_sort_peaksum_1sta_1stathresh_CZSB_events.txt</code> </li> </ul> <p>For the 14,474 events, output a catalog-like formatted list:  </p> <pre><code>~/FAST/utils/events/$ python output_final_detection_list.py\n</code></pre> <p>Output: <code>FINAL_Detection_List_BrazilAcre_1sta_1stathresh_peaksum6.txt</code> (14,474 events)  </p>"},{"location":"calipatria_dataset/","title":"0.11 Calipatria, June 2021","text":"<p>Get stations and waveform data in directory: <code>/app/data/20210605_Calipatria_data/</code></p> <pre><code>(eq_fast) root@6006660926e5:/app# cd parameters/preprocess/Calipatria/\n</code></pre> <p>Get station data in directory: /app/data/20210605_Calipatria_data/stations/  </p> <pre><code>(eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_station_list_Calipatria.py\n</code></pre> <p>For these stations, download waveform data in directory: <code>/app/data/20210605_Calipatria_data/waveforms/</code> </p> <p>Try the mass downloader first. Then try the get_waveforms function from client directly to get any data missed from mass downloader. You may need to run waveform download scripts multiple times to get all data.  </p> <pre><code>(eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_waveforms_mdl_Calipatria.py\n(eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_station_list_Calipatria.py\n</code></pre> <p>Not all stations from the original station list will have downloadable waveform data. Clean up the station list so that only stations with downloaded waveform data are included.  </p> <pre><code>(eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python clean_station_list_Calipatria.py\n</code></pre> <p>Need to manually arrange downloaded MSEED data into directories, with one directory per station named as: <code>/app/data/20210605_Calipatria_data/waveforms${STATION_NAME}/</code> </p>"},{"location":"calipatria_dataset/#preprocess","title":"Preprocess","text":"<p>apply 4-12 Hz bandpass filter to all MSEED data, decimate to 25 Hz (factor of 4 for 100-sps data; factor of 8 for 200-sps data). This script will output MSEED data named with \u201cDeci..\u201d to be used in FAST.  </p> <pre><code>(eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# cd ../../../utils/preprocess/\n(eq_fast) root@6006660926e5:/app/utils/preprocess# ../../parameters/preprocess/Calipatria/bandpass_filter_decimate_Calipatria.sh\n</code></pre>"},{"location":"calipatria_dataset/#fingerprint","title":"Fingerprint","text":"<p>43 stations, 113 channels  </p> <pre><code>(eq_fast) root@6006660926e5:/app/utils/preprocess# cd ../../fingerprint/\n(eq_fast) root@6006660926e5:/app/fingerprint# ../parameters/fingerprint/Calipatria/run_fp_Calipatria.sh\n</code></pre>"},{"location":"calipatria_dataset/#similarity-search","title":"Similarity Search","text":"<p>Ended up not using 6 PB stations (18 channels). Now 37 stations, 95 channels  </p> <pre><code>(eq_fast) root@6006660926e5:/app/fingerprint# cd ../simsearch/\n(eq_fast) root@6006660926e5:/app/simsearch# ../parameters/simsearch/Calipatria/run_simsearch_calipatria.sh\n</code></pre>"},{"location":"calipatria_dataset/#postprocessing","title":"Postprocessing","text":"<pre><code>(eq_fast) root@6006660926e5:/app/simsearch# cd ../postprocessing/\n(eq_fast) root@6006660926e5:/app/postprocessing# ../parameters/postprocess/Calipatria/output_calipatria_pairs.sh\n(eq_fast) root@6006660926e5:/app/postprocessing# ../parameters/postprocess/Calipatria/combine_calipatria_pairs.sh\n</code></pre>"},{"location":"calipatria_dataset/#network-detection","title":"Network detection","text":"<p>If list index out of range in partition, fails to keep running -&gt; try 1 partition  </p> <pre><code>(eq_fast) root@6006660926e5:/app/postprocessing# python scr_run_network_det.py ../parameters/postprocess/Calipatria/37sta_3stathresh_network_params.json\n</code></pre>"},{"location":"calipatria_dataset/#postprocess-clean-network-detection-results","title":"Postprocess: Clean Network Detection Results","text":"<pre><code>(eq_fast) root@6006660926e5:/app/postprocessing# cd ../utils/network/\n(eq_fast) root@6006660926e5:/app/utils/network# python arrange_network_detection_results.py\n</code></pre> <p>Input parameter changes made to <code>arrange_network_detection_results.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>det_dir = \u2018../../data/20210605_Calipatria_Data/network_detection/\u2019\nnetwork_file = \u201837sta_3stathresh_detlist_rank_by_peaksum.txt\u2019\nnsta = 37\n</code></pre> <pre><code>(eq_fast) root@6006660926e5:/app/utils/network# ./remove_duplicates_after_network.sh\n</code></pre> <p>Input parameter changes made to <code>remove_duplicates_after_network.sh</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>cd ../../data/20210605_Calipatria_Data/network_detection/\nNETWORK_FILE=NetworkDetectionTimes_37sta_3stathresh_detlist_rank_by_peaksum.txt\n</code></pre> <pre><code>(eq_fast) root@6006660926e5:/app/utils/network# python delete_overlap_network_detections.py\n</code></pre> <p>Input parameter changes made to <code>delete_overlap_network_detections.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>input_dir = \u2018../../data/20210605_Calipatria_Data/network_detection/\u2019\nallfile_name = input_dir+\u2018uniquestart_sorted_no_duplicates.txt\u2019\noutfile_name = input_dir+\u201837sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt\u2019\nn_sta = 37\n</code></pre> <pre><code>(eq_fast) root@6006660926e5:/app/utils/network# ./final_network_sort_nsta_peaksum.sh\n</code></pre> <p>Input parameter changes made to <code>final_network_sort_nsta_peaksum.sh</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>cd ../../data/20210605_Calipatria_Data/network_detection/\nNETWORK_FILE=37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre>"},{"location":"calipatria_dataset/#visualize-the-fast-output-739-events","title":"Visualize the FAST output (739 events)","text":"<pre><code>(eq_fast) root@6006660926e5:/app/utils/network# cat ../../data/20210605_Calipatria_Data/network_detection/sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre>"},{"location":"calipatria_dataset/#display-fast-detection-waveforms-descending-order-of-peaksum-similarity","title":"Display FAST detection waveforms, descending order of peaksum-similarity","text":"<pre><code>(eq_fast) root@6006660926e5:/app/utils/network# cd ../events/\n(eq_fast) root@6006660926e5:/app/utils/events# python PARTIALplot_detected_waveforms_Calipatria.py 0 739\n</code></pre> <p>Input parameter changes made to <code>PARTIALplot_detected_waveforms_Calipatria.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>times_dir = \u2018../../data/20210605_Calipatria_Data/network_detection/\u2019\n</code></pre> <pre><code>out_dir = times_dir+\u201837sta_3stathresh_NetworkWaveformPlots/\u2019\n</code></pre> <pre><code>dt_fp = 1.2\n</code></pre> <pre><code>init_time = UTCDateTime(\u20182021-06-05T00:00:06.840000\u2019)\n</code></pre> <pre><code>ts_dir = \u2018../../data/20210605_Calipatria_Data/\u2019\nst = read(ts_dir+\u2018waveforms*/Deci*Z__20210605T000000Z__20210606T000000Z.mseed\u2019) # Plot only vertical component\n</code></pre>"},{"location":"calipatria_dataset/#set-detection-threshold-keep-all-events-with-at-least-3-stations","title":"Set detection threshold - keep all events with at least 3 stations","text":"<pre><code>(eq_fast) root@6006660926e5:/app/utils/events# cd ../../data/20210605_Calipatria_Data/network_detection/\n(eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/network_detection# head -739 sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt &gt; EQ_sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre>"},{"location":"calipatria_dataset/#output-final-fast-detected-event-list","title":"Output final FAST detected event list","text":"<pre><code>(eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/network_detection# cd ../../../utils/events/\n(eq_fast) root@6006660926e5:/app/utils/events# python output_final_detection_list.py\n</code></pre> <p>Input parameter changes made to <code>output_final_detection_list.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>times_dir = \u2018../../data/20210605_Calipatria_Data/network_detection/\u2019\ninfile_name = \u2018EQ_sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt\u2019\noutfile_name = times_dir+\u2018FINAL_Detection_List_Calipatria_37sta_3stathresh.txt\u2019\ninit_time = UTCDateTime(\u20182021-06-05T00:00:06.840000\u2019) # global start time for all channels\ndt_fp = 1.2\n</code></pre> <pre><code>(eq_fast) root@6006660926e5:/app/utils/events# cat ../../data/20210605_Calipatria_Data/network_detection/FINAL_Detection_List_Calipatria_37sta_3stathresh.txt\n</code></pre>"},{"location":"calipatria_dataset/#cut-event-sac-files-for-phase-picking","title":"Cut event SAC files for phase picking","text":"<pre><code>(eq_fast) root@6006660926e5:/app/utils/events# python cut_event_files.py\n</code></pre> <p>Input parameter changes made to <code>cut_event_files.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>stations = [\u201cUSGCB\u201d, \u201cBC3\", \u201cBOM\u201d, \u201cCLI2\", \u201cCOA\u201d, \u201cCOK2\", \u201cCRR\u201d,\n\u201cCTC\u201d, \u201cCTW\u201d, \u201cDRE\u201d, \u201cERR\u201d, \u201cFRK\u201d, \u201cIMP\u201d, \u201cNSS2\",\n\u201cOCP\u201d, \u201cRXH\u201d, \u201cSAL\u201d, \u201cSLB\u201d, \u201cSLV\u201d, \u201cSNR\u201d, \u201cSWP\u201d,\n\u201cSWS\u201d, \u201cTHM\u201d, \u201cWMD\u201d, \u201cWWF\u201d, \u201c286\", \u201c5056\u201d, \u201c5058\",\n\u201c5062\u201d, \u201c5271\", \u201c5274\u201d, \u201c5444\",\n\u201cWLA\u201d, \u201cWLA01\", \u201cWLA03\u201d, \u201cWLA04\", \u201cWLA06\u201d]\nin_mseed_dir = \u2018../../data/20210605_Calipatria_Data/\u2019\nin_FINAL_Detection_List = \u2018../../data/20210605_Calipatria_Data/network_detection/FINAL_Detection_List_Calipatria_37sta_3stathresh.txt\u2019\nout_dir = \u2018../../data/20210605_Calipatria_Data/event_ids\u2019\ninit_time = UTCDateTime(\u20182021-06-05T00:00:06.840000\u2019, precision=2) # global start time for all channels\ndt_fp = 1.2\n</code></pre> <pre><code>st = read(\u2018../../data/20210605_Calipatria_Data/waveforms*/[!Deci]*.mseed\u2019)\n</code></pre>"},{"location":"calipatria_dataset/#pick-phases-with-seisbench","title":"Pick phases with SeisBench","text":"<pre><code>(eq_fast) root@6006660926e5:/app/utils/events# cd ../picking/\n(eq_fast) root@6006660926e5:/app/utils/picking# python run_seisbench.py\n</code></pre> <p>Input parameter changes made to <code>run_seisbench.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>base_dir = \u2018../../data/20210605_Calipatria_Data/\u2019\n</code></pre> <pre><code>stations = [\u2018CLI2\u2019, \u2018COK2\u2019, \u2018OCP\u2019, \u2018SAL\u2019, \u2018WWF\u2019, \u20185062\u2019, \u20185271\u2019, \u20185444\u2019]\n</code></pre>"},{"location":"calipatria_dataset/#earthquake-location-with-hypoinverse","title":"Earthquake location with HYPOINVERSE","text":"<pre><code>(eq_fast) root@6006660926e5:/app/utils/picking# cd ../location/\n(eq_fast) root@6006660926e5:/app/utils/location# python SeisBench2hypoinverse.py\n</code></pre> <p>Input parameter changes made to <code>SeisBench2hypoinverse.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>base_dir = \u2018../../data/20210605_Calipatria_Data/\u2019\nstart_lat = 33.1\nstart_lon = -115.6\nstart_depth = 5\n</code></pre> <pre><code>(eq_fast) root@6006660926e5:/app/utils/location# python output_station_file.py\n</code></pre> <p>Input parameter changes made to <code>output_station_file.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>base_dir = \u2018../../data/20210605_Calipatria_Data/\u2019\n</code></pre> <pre><code>(eq_fast) root@6006660926e5:/app/utils/location# cd ../../data/20210605_Calipatria_Data/location_hypoinverse/\n(eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/location_hypoinverse/# ../../../utils/location/hyp1.40/source/hyp1.40\nCOMMAND? @locate_events.hyp\n(eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/location_hypoinverse/# cd ../../../utils/location/\n(eq_fast) root@6006660926e5:/app/utils/location# python output_hypoinverse_as_text.py\n</code></pre> <p>Input parameter changes made to <code>output_hypoinverse_as_text.py</code> (from Hector Mine -&gt; Calipatria)  </p> <pre><code>catalog_start_time = UTCDateTime(\u20182021-06-05T00:00:06.840000\u2019)\nloc_dir = \u2018../../data/20210605_Calipatria_Data/location_hypoinverse/\u2019 \n</code></pre>"},{"location":"calipatria_dataset/#mapping-earthquake-locations-with-pygmt","title":"Mapping earthquake locations with PyGMT","text":"<pre><code>(eq_fast) root@6006660926e5:/app/utils/location# cd ../mapping/\n(eq_fast) root@6006660926e5:/app/utils/mapping# conda deactivate\nroot@6006660926e5:/app/utils/mapping# conda activate pygmt\n(pygmt) root@6006660926e5:/app/utils/mapping# python hypoinverse_to_pygmt_Calipatria.py\n</code></pre> Plots of detected earthquakes from FAST output"},{"location":"earthquake_location/","title":"Earthquake Location","text":"<p>The phase pick information from <code>run_seisbench.py</code> is saved in <code>event_picks.json</code> in <code>/FAST/utils/picking/event_picks.json</code> and is used as input for finding the earthquake locations, starting with <code>SeisBench2hypoinverse.py</code>.  </p> <p><code>SeisBench2hypoinverse.py</code> will format the needed earthquake information as input for HYPOINVERSE.  </p> <p>HYPOINVERSE is the standard location program supplied with the Earthworm seismic acquisition and processing system (AQMS). Read more about it here.  </p>"},{"location":"earthquake_location/#make-changes-to-seisbench2hypoinversepy","title":"Make Changes to <code>SeisBench2hypoinverse.py</code>","text":"<ul> <li>Change output file name:  </li> </ul> <pre><code>out_hinv_phase_file = 'EQT_19991015_test.txt' # Change file name for your dataset\n</code></pre>"},{"location":"earthquake_location/#get-station-list","title":"Get Station List","text":"<p>You will need to edit <code>eqt_get_station_list.py</code> in <code>/FAST/utils/location/</code> for your dataset:  </p> <ul> <li>Starting with getting the data</li> </ul> <pre><code># Hector Mine data\nclientlist=[\"SCEDC\"]\nminlat=34.1\nmaxlat=34.9\nminlon=-116.7\nmaxlon=-116\n</code></pre> <ul> <li>Choose channels you want to download</li> </ul> <pre><code>chan_priority_list=[\"HH[ZNE12]\", \"BH[ZNE12]\", \"EH[ZNE12]\", \"HN[ZNE12]\"] # Hector Mine data\n</code></pre> <ul> <li>Add event start and end time:</li> </ul> <pre><code>tstart=\"1999-10-12 00:00:00.00\" # Hector Mine data\n</code></pre> <pre><code>tend=\"1999-10-17 00:00:00.00\" # Hector Mine data\n</code></pre>"},{"location":"earthquake_location/#information-about-locate_eventshyp-input-files","title":"Information About <code>locate_events.hyp</code> input files","text":"<p>Input files <code>locate_events.hyp</code> relies on:  </p> <ul> <li>CRH 1 \u2018hadley.crh\u2019  </li> <li>STA \u2018station_list.sta\u2019  </li> <li>PHS \u2018EQT_19991015_test.txt\u2019  </li> <li>SUM \u2018locate_events.sum\u2019  </li> <li>ARC \u2018locate_events.arc\u2019  </li> </ul> <p><code>hadley.crh</code> is the velocity model input file. It approximates the p-wave speed (km/s) underground, at a given depth in km. You\u2019ll need this to calculate earthquake locations from the phase pick times. The first column has p-wave speed in km/s. The second column has depth in km. The p-wave speed is 5.5 km/s at depths from 0 to 5.5 km, 6.3 km/s at depths from 5.5 to 16 km, 6.7 km/s at depths from 16 to 32 km, and 7.8 km/s at depths deeper than 32 km.</p> <pre><code>POS 1.73                /P to S ratio\n</code></pre> <p>This line in the <code>locate_events.hyp</code> file tells you the ratio between p wave and s wave speed.  S wave speed is always slower than p wave speed, so s picks are always later than p picks.  You can divide the first column of numbers in hadley.crh by 1.73 to get the s-wave speeds; that\u2019s what HYPOINVERSE does internally.</p> <p><code>PHS \u2018EQT_19991015_test.txt\u2019</code> - that\u2019s the all-important file your script generated, that has the approximate origin times and phase pick times from SeisBench.  </p> <p><code>STA \u2018station_list.sta\u2019</code> - this is the station file, which has the list of station names and their locations.  There are scripts you can run to create this file shown in Tutorial.  </p>"},{"location":"earthquake_location/#change-file-name-in-locate_eventshyp","title":"Change File Name in <code>locate_events.hyp</code>","text":"<p>The output changed above in <code>SeisBench2hypoinverse.py</code> is used in <code>locate_events.hyp</code> </p> <ul> <li>Change file name for your dataset in <code>locate_events.hyp</code>:  </li> </ul> <pre><code>PHS 'EQT_19991015_test.txt' # Change file name for your dataset\n</code></pre>"},{"location":"earthquake_location/#plotting-hypoinverse-location-results-with-pygmt","title":"Plotting HYPOINVERSE Location Results With PyGMT","text":"<p>IMPORTANT - PyGMT needs to be installed and run in a separate <code>pygmt</code> conda environment, since it is incompatible with the <code>eq_fast</code> conda environment.  </p> <p>Follow the steps in the tutorial section to user PyGMT.  </p>"},{"location":"ex_params/","title":"Example Parameters","text":""},{"location":"ex_params/#01-introduction","title":"0.1 Introduction","text":"<p>FAST is available to the public at https://github.com/stanford-futuredata/FAST as open-source software, and it will be released with a comprehensive user manual containing guidance for setting parameters. Interested users can run FAST to perform an uninformed search for earthquakes with similar waveforms on any seismic network, with varying duration of continuous data and number of stations. The FAST software has successfully detected earthquakes in the following data sets. FAST will only reach its full potential as a tool for seismological discovery if other users apply it to their own data sets (filling the N and T gaps in Figure 1) and improve the detection algorithms. Thank you to all collaborators and interested users who shared data, which was useful for testing the FAST software and identifying bug fixes, in preparation for its public release.  </p> <p> </p> Figure 1: Dimensions of different data sets where FAST has successfully detected similar earthquakes. The log-scale axes represent the directions of data growth in seismology to \u201dlarge-T\u201d and \u201dlarge-N\u201d big data sets (Chapters 1 and 5): T is the longest duration of continuous data over all stations in the data set, while N is the number of seismic stations in the data set. Blue stars: data sets from Chapters 2-5. Red stars: additional data sets from Appendix A, Sections A.1-A.6."},{"location":"ex_params/#02-italydayyr-data-set","title":"0.2 <code>ItalyDayYR</code> Data Set","text":"<p>Info</p> <p>One day of continuous data, 2016-10-29 00:00:00 to 2016-10-29 23:59:59 UTC, at 22 stations in central Italy (Figure 2), used 22 channels (vertical component HHZ only on each channel) for detection, provided by Bill Ellsworth. This data records small earthquakes from a swarm in Central Italy during October 2016, that occurred between the Mw 6.1 earthquake on 2016-10-26 19:18:08 UTC and the Mw 6.6 Norcia earthquake on 2016-10-30 06:40:18 UTC.  </p> <p> </p> Figure 2: Map of 22 stations (black triangles) in central Italy used for FAST detection of small earthquakes on 2016-10-29, one day of continuous data. The INGV catalog (http://cnt.rm.ingv.it/search) had 482 earthquakes (circles colored by depth, sized by relative magnitudes 0.4 \u2264 M \u2264 4.1) inside the boundaries of this map on 2016-10-29."},{"location":"ex_params/#021-preprocessing","title":"0.2.1 Preprocessing","text":"<p>Output sample spectrograms on each channel and station to determine bandpass filter range:  </p> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/ItalyDayYR/sample_spectrograms_ItalyDayYR.sh\n</code></pre> <p>Table S2: FAST input parameters for Italy earthquake detection: single-channel at 22 YR stations (Figure 2, black triangles), after bandpass filter 2-20 Hz, and decimate to 25 Hz. Total number of fingerprints: 71,989.  </p> <p> </p> <p>Table S3: Network detection input parameters for Italy earthquakes at 22 YR stations (HHZ channel only), after getting similar pairs of fingerprints from FAST for each station.  </p> <p> </p> <p> </p> Figure 3: Distribution of FAST detections in central Italy continuous data on 2016-10-29. FAST detected a total of 1,485 earthquakes during this day."},{"location":"ex_params/#03-tanzania-august-2016","title":"0.3 Tanzania, August 2016","text":"<p>Temporary dense deployment of seismic stations in Tanzania to identify previously unknown faults and infer their dimensions. 1 month continuous data (2016-07-31 to 2016-08-31), at 5 stations, 15 channels (3 components per station), provided by Laura Parisi of King Abdullah University of Science and Technology (KAUST). The stations are located about 10 km apart, at the base of a volcanic caldera called Ngorongoro Crater. For all 15 channels, we applied the following preprocessing: 4-12 Hz bandpass filter, then decimated to 25 Hz (factor of 8, from original 200 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise (only on station CES04).  </p> <p>Table S4: FAST input parameters for Tanzania earthquake detection, applied to each component at all 5 stations. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989.  </p> <p> </p> <p>Table S5: Network detection input parameters for Tanzania earthquakes at 5 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HNE,HNN,HNZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6.  </p> <p> </p> <p>Table S6: Final thresholds for Tanzania earthquakes, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.  </p> <p> </p> <p> </p> Figure 4: Tanzania earthquake detections from 2016-07-31 to 2016-08-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S6). FAST detected a total of 1,156 earthquakes during this month. Some false positive detections had to be removed manually, especially detections on only 2 out of 5 stations."},{"location":"ex_params/#04-saudi-arabia-may-2014","title":"0.4 Saudi Arabia, May 2014","text":"Figure 5: Map of 19 stations (white triangles) in Saudi Arabia used for FAST detection from 2014-05-01 to 2014-06-01. Catalog earthquakes are colored by depth; mantle earthquakes are circled. This figure was created by Alex Blanchette. <p>Info</p> <p>Seismic network from Saudi Arabia to study dike swarms in volcanic area, and deep mantle earthquakes. 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations (Figure 5), 55 channels (3 components per station, except LNY11 where only HHN was used), provided by Alex Blanchette of Stanford Geophysics.  </p> <p>Table S7: Preprocessing parameters for Saudi Arabia May 2014 earthquake detection, for each station (same filter applied to all components), 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations, decimate to 25 Hz. Also, all time gaps with 0\u2019s were filled with uncorrelated random noise. For station LNY11, only HHN component was used in similarity search, as the HHE and HHZ components had too much correlated noise.  </p> <p> </p> <p>Table S8: FAST input parameters for Saudi Arabia May 2014 earthquake detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989.  </p> <p> </p> <p>Table S9: Network detection input parameters for Saudi Arabia May 2014 earthquake detection at 19 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6.  </p> <p> </p> <p>Table S10: Final thresholds for Saudi Arabia May 2014 earthquake detection, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.  </p> <p> </p> <p> </p> Figure 6: Saudi Arabia earthquake detections from 2014-05-01 to 2014-06-01. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S10). FAST detected a total of 1,837 earthquakes during this month."},{"location":"ex_params/#05-saudifull-data-set-saudi-arabia-january-may-2017","title":"0.5 <code>SaudiFull</code> data set: Saudi Arabia, January - May 2017","text":"<ul> <li>Location: Saudi Arabia, January - May 2017 (volcanic area with dikes)  </li> <li>Duration: up to 5 months (151 days): 2017-01-01 to 2017-05-30  </li> <li>Network: 36 stations, 3 components each (HHE, HHN, HHZ) = 106 channels. (Station SA.UMJ02: only HHE channel)  </li> <li>Sampling rate: 100 Hz  </li> <li>Provided by: Mohammad Youssof (KAUST)  </li> </ul>"},{"location":"ex_params/#051-preprocessing","title":"0.5.1 Preprocessing","text":"<ul> <li>Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/continuous_data_times_SaudiFull.sh\n</code></pre> <p>The output files in <code>continuous_duration/</code> can be read into a custom script called <code>plot_continuous_ duration_SaudiFull.py</code> to plot the duration of available continuous data at each station and channel (Figure 7).  </p> <p> </p> Figure 7: Duration of SaudiFull continuous data at 36 stations (change colors with each station), 3 components each (except SA.UMJ02 which has only HHE). White sections indicate time gaps. <ul> <li>Detected zero-filled time-gap sections of continuous data in all 106 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py), and filled them with random uncorrelated noise:  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py  \n</code></pre> <p>Only stations SA.UMJ03, SA.UMJ05, SA.UMJ08 had zero-filled time-gap sections, which were filled with random noise and saved as files starting with the <code>Filled.*</code> string. The majority of continuous data files had no zero-filled time gaps, so we used original mseed data files.  </p> <ul> <li>Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/sample_spectrograms_SaudiFull.sh\n</code></pre> <ul> <li>Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/bandpass_filter_decimate_SaudiFull.sh\n</code></pre> <p>Based on sample spectrograms, apply a station-specific bandpass filter (Table S11). Decimate by a factor of 2 to a sampling rate of 50 Hz. Filtered continuous data files start with <code>Deci2.bpXtoY.*</code>, where X is the lower frequency and Y is the higher frequency, which are input to the fingerprint step.  </p> <p>Table S11: Preprocessing parameters for SaudiFull earthquake detection, for each station (same filter applied to all components), 5 months continuous data (2017-01-01 to 2017-05-31), at 36 stations, decimate to 50 Hz.  </p> <p> </p>"},{"location":"ex_params/#052-fingerprint","title":"0.5.2 Fingerprint","text":"<p>Master script to create fingerprints on each channel, then generate global indices at the end:  </p> <pre><code>~/FAST/fingerprint/$ ../parameters/fingerprint/SaudiFull/run_fp_SaudiFull.sh\n</code></pre> <p>Example script to generate fingerprints on one channel (HHZ) at one station (LNY03), called by the master script run_fp_SaudiFull.sh:  </p> <pre><code>~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/SaudiFull/fp_input_SA_LNY03_HHZ.json\n    \"fingerprint\": {\n       \"sampling_rate\": 50,\n       \"min_freq\": 4.0,\n       \"max_freq\": 15.0,\n       \"spec_length\": 6.0,\n       \"spec_lag\": 0.12,\n       \"fp_length\": 64,\n       \"fp_lag\": 10,\n       \"k_coef\": 400,\n       \"nfreq\": 32,\n       \"mad_sampling_rate\": 0.1,\n       \"mad_sample_interval\": 86400\n    \"data\": {\n       \"station\": \"LNY03\",\n       \"channel\": \"HHZ\",\n       \"start_time\": \"17-01-01T00:00:00.0\",\n       \"end_time\": \"17-05-31T00:00:00.0\",\n       \"folder\": \"/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/\",\n</code></pre> <p>There are a total of 106 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S12.  </p> <p>Median/MAD output files: <code>mad/mad*.txt</code> </p> <p>Table S12: Fingerprint input parameters for SaudiFull earthquake detection: 3-component at 36 stations (except for SA.UMJ02), after applying station-specific bandpass filter (Table S11), and sampled at 50 Hz. The fingerprint sampling period is dt_fp = 1.2 seconds.  </p> <p> </p> <p>Fingerprints (binary files): <code>fingerprints/LNY03.HHZ.fp</code> Timestamps at each fingerprint index (text files): <code>timestamps/LNY03.HHZ.ts</code> </p> <p>Finally, to create global indices for the SaudiFull data set, so that fingerprint indices from different channels (all 106) and stations are referenced to a common starting time:  </p> <pre><code>$ python global_index.py ../parameters/fingerprint/SaudiFull/global_indices_SaudiFull.json  \n</code></pre> <p>The common starting time is in <code>global_idx_stats.txt</code>: 2017-01-01T00:00:06.840000 UTC  </p>"},{"location":"ex_params/#053-similarity-search","title":"0.5.3 Similarity Search","text":"<p>Master script to run similarity search on each channel (out of 106 total):  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/run_simsearch_SaudiFull.sh  \n</code></pre> <p>Table S13: Similarity search input parameters for SaudiFull earthquake detection: 106 channels at 36 stations (3 components each, except SA.UMJ02). The occurrence filter, specified by the FREQ_NOISE parameter, was applied only for selected stations and channels (Table S14).  </p> <p> </p> <p>Example script to run similarity search on one channel (HHZ) at one station (LNY03), called by the master script <code>run_simsearch_SaudiFull.sh</code>:  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/simsearch_input_SaudiFull.sh LNY03 HHZ\nNTBLS=100\nNHASH=4\nNREPEAT=5\nNVOTES=2\nNTHREAD=56\nNUM_PART=1\n</code></pre> <p>We first ran similarity search with the same input parameters on all 106 channels, without the occurrence filter. For 18 selected channels (Table S14), where the <code>candidate_pairs</code> similarity search outputs were especially large because of correlated noise, we ran similarity search with the occurrence filter (FREQ_NOISE=0.01), which significantly reduced the similarity search output file sizes. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. For example, the occurrence filter was applied for station LNY01 channel HHZ by calling the script <code>filt_simsearch_input_SaudiFull.sh</code> from the master script <code>run_simsearch_SaudiFull.sh</code>:  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/filt_simsearch_input_SaudiFull.sh LNY03 HHZ\nNTBLS=100\nNHASH=4\nNREPEAT=5\nNVOTES=2\nNTHREAD=56\nNUM_PART=1\nFREQ_NOISE=0.01\n</code></pre> <p>Table S14: Selected stations and channels from SaudiFull data set where we applied the occurrence filter with FREQ_ NOISE=0.01.  </p> <p> </p>"},{"location":"ex_params/#054-postprocessing","title":"0.5.4 Postprocessing","text":"<p>First, run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (106 total):  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/output_SaudiFull_pairs.sh\n</code></pre> <p>For example, on one channel (HHZ) at one station (LNY03), all on one line:  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/\n-p candidate_pairs_LNY03_HHZ -i /lfs/1/ceyoon/TimeSeries/SaudiFull/global_indices/LNY03_HHZ_idx_mapping.txt\n</code></pre> <p>Output file for example (large size at channel level): <code>/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/candidate_pairs_LNY03_HHZ_merged.txt</code> </p> <p>Second, run the master script to combine similarity output from all 3 components at a given station, for all 36 stations:  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/combine_SaudiFull_pairs.sh  \n</code></pre> <p>Example</p> <p>For example, on three channels (HHE, HHN, HHZ) at one station (LNY03), first move the similarity output text files to the inputs_network/ directory:  </p> <pre><code>$ cd /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/\n$ mv candidate_pairs_LNY03_HH*_merged.txt ../../../inputs_network/\n</code></pre> <p>Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S13). Note: this step will delete the c<code>andidate_ pairs_LNY03_HH*_merged.txt</code> files.  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/\n-p candidate_pairs_LNY03 --sort true --parse false -c true -t 6\n</code></pre> <p>Output file for example (smaller size at station level): <code>/lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ candidate_pairs_LNY03_combined.txt</code> </p> <p>For station SA.UMJ02, which has only 1 component (HHE), multiply the similarity sim by 3 to give this station an equal weight as the other 3-component stations:  </p> <pre><code>~/FAST/postprocessing/$ awk \u2019{print $1, $2, 3*$3}\u2019\n/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_HHE_merged.txt\n&gt; /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_combined.txt\n</code></pre> <p>Finally, detect similar fingerprints across the network of 36 stations, using the input parameters in Table S15:  </p> <pre><code>~/FAST/postprocessing/$\npython scr_run_network_det.py ../parameters/postprocess/SaudiFull/36sta_3stathresh_network_params.json\n       \"network\": {\n              \"max_fp\": 10736786,\n              \"dt_fp\": 1.2, (seconds)\n              \"dgapL\": 10, (12 s)\n              \"dgapW\": 3, (3.6 s)\n              \"num_pass\": 2,\n              \"min_dets\": 3,\n              \"min_sum_multiplier\": 1,\n              \"max_width\": 8, (9.6 s)\n              \"ivals_thresh\": 6,\n              \"nsta_thresh\": 3,\n              \"input_offset\": 15 (18 s)\n},\n</code></pre> <p>Network detection output file for example (smaller size at station level): <code>/lfs/1/ceyoon/TimeSeries/SaudiFull/ network_detection/36sta_3stathresh_detlist_rank_by_peaksum.txt</code> (21,498 events)  </p> <p>At this point, FAST earthquake detection processing is done.  </p> <p>Table S15: Network detection input parameters for SaudiFull at 36 stations. max_fp = 10736786 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.2 seconds is the fingerprint sampling period from Table S12.  </p> <p> </p>"},{"location":"ex_params/#055-remove-duplicates-after-network-detection","title":"0.5.5 Remove Duplicates After Network Detection","text":"<p>Info</p> <p>The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.)  </p> <p>First, save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind).  </p> <pre><code>~/FAST/utils/network/$ python arrange_network_detection_results.py\n</code></pre> <p>Output: <code>NetworkDetectionTimes_36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events)</code> </p> <p>Second, remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity).  </p> <pre><code>~/FAST/utils/network/$ ./remove_duplicates_after_network.sh  \n</code></pre> <p>Output: <code>uniquestart_sorted_no_duplicates.txt (15,054 events)</code> </p> <p>Third, remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum.  </p> <pre><code>~/FAST/utils/network/$ python delete_overlap_network_detections.py  \n</code></pre> <p>Output: <code>36sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code> (11,597 events)  </p> <p>Fourth, since different channels in the network have different durations (for example, in Figure 7, stations UMJ01-UMJ12 were active only during May 2017, while many of the other stations were active from January to May 2017), we calculate a normalized measure of the number of stations that detected the event: frac_ch, which is the fraction of channels that were active at each detection time. This is done by reading in files that were generated during preprocessing by get_continuous_data_times.py. This normalization step would not be necessary if all stations and channels in the network recorded the same duration of data.  </p> <pre><code>~/FAST/utils/network/$ python get_station_count_detections.py\n</code></pre> <p>Output: <code>36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt</code> (11,597 events)  </p> <p>Finally, sort remaining events in descending order of num_sta, then frac_ch, then peaksum, for the final detection list.  </p> <pre><code>~/FAST/utils/network/$ ./final_network_sort_nsta_fracch_peaksum.sh\n</code></pre> <p>Output: <code>sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt</code> (11,597 events)  </p>"},{"location":"ex_params/#056-visual-inspection-and-final-detections","title":"0.5.6 Visual Inspection and Final Detections","text":"<p>Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table S16).  </p> <pre><code>~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_SaudiFull.py 0 11597\n</code></pre> <p>Output: <code>.png</code> image files in <code>36sta_3stathresh_NetworkWaveformPlots/</code> </p> <p>Table S16: Final thresholds for SaudiFull applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied.  </p> <p> </p> <p>After visual inspection, 4634 events are above thresholds in Table S16.  </p> <ul> <li><code>EQ_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt</code>: 4543 events that look like earthquake waveforms  </li> <li><code>FALSE_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt</code>: 91 false detections above thresholds that do not look like earthquakes  </li> </ul> <p>For the 4543 earthquake events, output an event catalog (Figure 8):  </p> <pre><code>~/FAST/utils/events/$ python output_final_detection_list.py\n</code></pre> <p>Output: <code>FINAL_Detection_List_SaudiFull_36sta_3stathresh.txt</code> (4543 events)  </p> <p> </p> Figure 8: Saudi Arabia earthquake detections from 2017-01-01 to 2017-05-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S16). FAST detected a total of 4,543 earthquakes during this month."},{"location":"ex_params/#06-ometepec-mexico-january-april-2012","title":"0.6 Ometepec, Mexico, January - April 2012","text":"Figure 9: Map of 1 station in southern Mexico (black triangle) used for FAST detection of small earthquakes from 2012-01-01 to 2012-04-21. The SSN catalog (http://www2.ssn.unam.mx:8080/catalogo/) had 558 earthquakes (circles colored by depth, sized by relative magnitudes 2.8 \u2264 M \u2264 7.5) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.5 Ometepec earthquake on 2012-03-20. <p>Info</p> <p>The objective of this study is to identify repeating earthquake sequences as tools to measure deep aseismic slip rates [Dominguez et al., 2016], and characterize the unusually active aftershock sequence of the Mw 7.5 Omepetec, Mexico earthquake on 2012-03-20 [UNAM, 2013] (Figure 9). 112 days of continuous data (2012-01-01 to 2012-04-21) at 1 station, 3 components, provided by Luis Dominguez of Universidad Nacional Autonoma de Mexico (UNAM)-Morelia. For all 3 channels, I applied a 3-20 Hz bandpass filter, and kept the original sampling rate of 100 Hz.  </p> <p>FAST detected a total of 31,970 earthquakes during these 4 months. 30,923 were earthquakes (Figure 10), and 1,047 were noise, as determined by visual inspection. ***NOTE: postprocessing and elimination of duplicate detection pairs was done with the old MATLAB code from [Yoon et al., 2015] and [Yoon et al., 2017]. Single-station event-pair extraction with network FAST was not yet available. These were the events I sent to Luis, who performed single-station location using P-wave polarization analysis (Figure 10).  </p> <p>Table S17: FAST input parameters for Ometepec, Mexico earthquake detection, applied to each component at station IG.PNIG. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 4,795,140.  </p> <p> </p> <p> </p> Figure 10: Ometepec, Mexico earthquake detections from 2012-01-01 to 2012-04-21. The blue dots indicate the total 3-component FAST similarity (left y-axis) of the 30,923 FAST detections as a function of time. The red dots indicate the magnitudes (right y-axis) of the 558 catalog events as a function of time. Following the Mw 7.5 earthquake on 2012-03-20, aftershocks are abundant."},{"location":"ex_params/#07-seismolympics-wenchuan-aftershocks","title":"0.7 SeismOlympics: Wenchuan Aftershocks","text":"<p>Info</p> <p>Alibaba Cloud and the China Earthquake Administration sponsored a \u201dSeismOlympics\u201d programming competition to detect aftershocks of the deadly May 12, 2008 Mw 7.9 Wenchuan, China, earthquake [Fang et al., 2017], similar to the Netflix Prize or the Kaggle data science competitions. Competitors from seismology, machine learning, signal processing, computer science, and other backgrounds developed algorithms that automatically detect and pick phases on aftershock waveforms while avoiding false positive detections. Performance was evaluated against phases picked by human analysts. This was a great opportunity to test how the FAST earthquake detection algorithm measured up against other methods. Other members of my team, all from Stanford Geophysics (Mostafa Mousavi, Yixiao Sheng, Weiqiang Zhu) used machine learning to pick phases and recognize false detections. We finished in 27th place in the first round of competition, and 16th place in the second round.  </p> <p> </p> Figure 11: Map of 15 stations in Wenchuan, China used for FAST detection of small earthquakes in 3 months of continuous data. The ComCat catalog had 1039 aftershocks (circles colored by depth, sized by relative magnitudes 3.2 \u2264 M \u2264 6.1) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.9 Wenchuan earthquake on 2008-05-12.  <p>After the competition, I applied FAST to detect earthquakes within the entire continuous data set provided in both rounds of competition. 3 months of seismic data: April 1-22, 2008 (foreshocks), July 1-August 31, 2008 (aftershocks), at 15 stations (Figure 11) with 3 components each, although some stations only have data for part of this time. For all 45 channels, I applied the following preprocessing: 1-20 Hz bandpass filter, then decimated to 50 Hz (factor of 2, from original 100 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise. FAST detected about 12,000 earthquakes; some of them are teleseismic because the 1-20 Hz filter includes lower frequencies.  </p> <p>Table S18: FAST input parameters for Wenchuan 2008 aftershock detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 3,612,972.  </p> <p> </p> <p>Table S19: Network detection input parameters for Wenchuan 2008 aftershock detection at 15 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6.  </p> <p> </p> <p>Table S20: Final thresholds for Wenchuan 2008 aftershock detection applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.  </p> <p> </p>"},{"location":"ex_params/#08-groningen-data-set","title":"0.8 <code>Groningen</code> Data Set","text":"<ul> <li>Location: Netherlands (gas production field)  </li> <li>Duration: 4 months (119 days): 2018-01-01 to 2018-04-30  </li> <li>Network: 67 stations (Figure 12), 3 components each (HH1, HH2, HHZ) = 201 channels. (Station G294 not used for detection due to short duration)  </li> <li>Sampling rate: 20 Hz (already downsampled)  </li> <li>Provided by: Zack Spica (Stanford Geophysics)  </li> </ul> Figure 12: Groningen map provided by Zack Spica: 67 stations (black, red triangles) used for FAST detection, and locations of known catalog events (blue circles)."},{"location":"ex_params/#081-preprocessing","title":"0.8.1 Preprocessing","text":"<ul> <li>Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/continuous_data_times_Groningen.sh\n</code></pre> Figure 13: Duration of Groningen continuous data at 67 stations (change colors with each station), 3 components each. White sections indicate time gaps. <p>The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_Groningen.py to plot the duration of available continuous data at each station and channel (Figure 13).  </p> <ul> <li>Confirmed no zero-filled time-gap sections of continuous data in all 201 channels (need to modify paths in fill_time_gaps_with_uncorrelated_noise.py):  </li> </ul> <p><pre><code>~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py\n</code></pre> Use original mseed data files. </p> <ul> <li>Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/sample_spectrograms_Groningen.sh\n</code></pre> <ul> <li>Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/bandpass_filter_decimate_Groningen.sh\n</code></pre> <p>Based on sample spectrograms, filter 3-10 Hz for all 201 channels. No need to decimate, as sampling rate is already low at 20 Hz. Filtered continuous data files start with Deci1.bp3to10.*, which are input to the fingerprint step.  </p>"},{"location":"ex_params/#082-fingerprint","title":"0.8.2 Fingerprint","text":"<p>Master script to create fingerprints on each channel, then generate global indices at the end:  </p> <p><pre><code>~/FAST/fingerprint/$ ../parameters/fingerprint/Groningen/run_fp_Groningen.sh\n</code></pre> Example script to generate fingerprints on one channel (HHZ) at one station (G014), called by the master script run_fp_Groningen.sh: </p> <pre><code>~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/Groningen/fp_input_NL_G014_HHZ.json\n    \"fingerprint\": {\n       \"sampling_rate\": 20,\n       \"min_freq\": 3.0,\n       \"max_freq\": 10.0,\n       \"spec_length\": 6.0,\n       \"spec_lag\": 0.12,\n       \"fp_length\": 64,\n       \"fp_lag\": 10,\n       \"k_coef\": 400,\n       \"nfreq\": 32,\n       \"mad_sampling_rate\": 0.05,\n       \"mad_sample_interval\": 86400\n    \"data\": {\n       \"station\": \"G014\",\n       \"channel\": \"HHZ\",\n       \"start_time\": \"18-01-01T00:00:00.0\",\n       \"end_time\": \"18-04-30T00:00:00.0\",\n       \"folder\": \"/lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/\",\n</code></pre> <p>There are a total of 201 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S21.  </p> <p>Table S21: Fingerprint input parameters for Groningen earthquake detection: 3-component at 67 stations (Figure 12, red, black triangles), after bandpass filter 3-10 Hz, and sampled at 20 Hz. The fingerprint sampling period is dt_fp = 1.5 seconds.  </p> <p> </p> <p>Median/MAD output files: <code>mad/mad*.txt</code> Fingerprints (binary files): <code>fingerprints/G014.HHZ.fp</code> Timestamps at each fingerprint index (text files): <code>timestamps/G014.HHZ.ts</code> </p> <p>Finally, to create global indices for the Groningen data set, so that fingerprint indices from different channels (all 201) and stations are referenced to a common starting time:  </p> <pre><code>$ python global_index.py ../parameters/fingerprint/Groningen/global_indices_Groningen.json  \n</code></pre> <p>The common starting time is in <code>global_idx_stats.txt</code>: 2018-01-01T00:00:04.500000 UTC </p>"},{"location":"ex_params/#083-similarity-search","title":"0.8.3 Similarity Search","text":"<p>Master script to run similarity search on each channel (out of 201 total):  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/Groningen/run_simsearch_Groningen.sh\n</code></pre> <p>Table S22: Similarity search input parameters for Groningen earthquake detection: 201 channels at 67 stations (3 components each).  </p> <p> </p> <p>Example script to run similarity search on one channel (HHZ) at one station (G014), called by the master script run_simsearch_Groningen.sh: </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/Groningen/filt_simsearch_input_Groningen.sh G014 HHZ\nNTBLS=100\nNHASH=5\nNREPEAT=5\nNVOTES=2\nNTHREAD=56\nNUM_PART=1\nFREQ_NOISE=0.01\n</code></pre> <p>Similarity search is run with the occurrence filter (FREQ_NOISE=0.01) for all 201 channels. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. The same input parameters are used for similarity search on all 201 channels (Table S22).  </p>"},{"location":"ex_params/#084-postprocessing","title":"0.8.4 Postprocessing","text":"<p>First, run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (201 total):  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/output_Groningen_pairs.sh\n</code></pre> <p>For example, on one channel (HHZ) at one station (G014), all on one line:  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/\n-p candidate_pairs_G014_HHZ -i /lfs/1/ceyoon/TimeSeries/Groningen/global_indices/G014_HHZ_idx_mapping.txt\n</code></pre> <p>Output file for example (large size at channel level): <code>/lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/ fingerprints/candidate_pairs_G014_HHZ_merged.txt</code> </p> <p>Second, run the master script to combine similarity output from all 3 components at a given station, for all 67 stations:  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/combine_Groningen_pairs.sh\n</code></pre> <p>For example, on three channels (HH1, HH2, HHZ) at one station (G014), first move the similarity output text files to the inputs_network/ directory:  </p> <pre><code>$ cd /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/\n$ mv candidate_pairs_G014_HH*_merged.txt ../../../inputs_network/\n</code></pre> <p>Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)(v=2 votes/component, Table S22). Note: this step will delete the candidate_ pairs_G014_HH_merged.txt files.  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/\n-p candidate_pairs_G014 --sort true --parse false -c true -t 6\n</code></pre> <p>Output file for example (smaller size at station level):<code>/lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ candidate_pairs_G014_combined.txt</code> </p> <p>Finally, detect similar fingerprints across the network of 67 stations, using the input parameters in Table S23:  </p> <pre><code>~/FAST/postprocessing/$\npython scr_run_network_det.py ../parameters/postprocess/Groningen/67sta_3stathresh_network_params.json\n       \"network\": {\n              \"max_fp\": 6798013,\n              \"dt_fp\": 1.5, (seconds)\n              \"dgapL\": 10, (15 s)\n              \"dgapW\": 3, (4.5 s)\n              \"num_pass\": 2,\n\n28\n},\n</code></pre> <p>Table S23: Network detection input parameters for Groningen at 67 stations. max_fp = 6798013 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.5 seconds is the fingerprint sampling period from Table S21.  </p> <p> </p> <p>Network detection output file for example (smaller size at station level): <code>/lfs/1/ceyoon/TimeSeries/Groningen/ network_detection/67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events)</code> </p> <p>At this point, FAST earthquake detection processing is done.  </p>"},{"location":"ex_params/#085-remove-duplicates-after-network-detection","title":"0.8.5 Remove duplicates after network detection","text":"<p>The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.)  </p> <p>First, save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind).  </p> <pre><code>~/FAST/utils/network/$ python arrange_network_detection_results.py\n</code></pre> <p>Output: <code>NetworkDetectionTimes_67sta_3stathresh_detlist_rank_by_peaksum.txt</code> (118,728 events)  </p> <p>Second, remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity).  </p> <pre><code>~/FAST/utils/network/$ ./remove_duplicates_after_network.sh\n</code></pre> <p>Output: <code>uniquestart_sorted_no_duplicates.txt</code> (13,782 events)  </p> <p>Third, remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum.  </p> <pre><code>~/FAST/utils/network/$ python delete_overlap_network_detections.py\n</code></pre> <p>Output: <code>67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code> (6277 events)  </p> <p>Finally, sort remaining events in descending order of num_sta, then peaksum, for the final detection list.  </p> <pre><code>~/FAST/utils/network/$ ./final_network_sort_nsta_peaksum.sh\n</code></pre> <p>Output: <code>sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code> (6277 events)  </p>"},{"location":"ex_params/#086-visual-inspection-and-final-detections","title":"0.8.6 Visual inspection and final detections","text":"<p>Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table 0.8.6).  </p> <pre><code>~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_Groningen.py 0 6277\n</code></pre> <p>Output: <code>.png</code> image files in <code>67sta_3stathresh_NetworkWaveformPlots/</code> </p> <p>Table S24: Final thresholds for Groningen applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied.  </p> <p> </p> <p>After visual inspection, 26 events are above thresholds in Table 0.8.6.  </p> <ul> <li><code>EQ_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code>: 23 events that look like earthquake waveforms  </li> <li><code>FALSE_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code>: 3 false detections above thresholds that do not look like earthquakes  </li> </ul> <p>For the 23 earthquake events, output an event catalog:  </p> <pre><code>~/FAST/utils/events/$ python output_final_detection_list.py\n</code></pre> <p>Output: <code>FINAL_Detection_List_Groningen_67sta_13stathresh.txt</code> (23 events)  </p>"},{"location":"ex_params/#09-brazilacre-data-set","title":"0.9 <code>BrazilAcre</code> Data Set","text":"<ul> <li>Location: Acre, Brazil (search for intermediate-depth and deep earthquakes)  </li> <li>Duration: about 3 months (with time gaps): 2015-05-28 to 2016-02-01  </li> <li>Network: 1 station (Figure 14), 3 components (HHE, HHN, HHZ) = 3 channels. \u2022 Sampling rate: 100 Hz  </li> <li>Provided by: Marcelo de Bianchi (University of Sao Paulo)  </li> </ul> Figure 14: Acre, Brazil map provided by Marcelo de Bianchi: 1 station (yellow triangle) used for FAST detection, and locations of known catalog events (circles colored by depth)."},{"location":"ex_params/#091-preprocessing","title":"0.9.1 Preprocessing","text":"<ul> <li>Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/continuous_data_times_BrazilAcre.sh\n</code></pre> <p>The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_BrazilAcre.py to plot the duration of available continuous data at each station and channel (Figure 15).  </p> <p> </p> Figure 15: Duration of BrazilAcre continuous data at 1 station (3 components). White sections indicate time gaps. <ul> <li>Confirmed no zero-filled time-gap sections of continuous data in all 3 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py\n</code></pre> <p>Use original mseed data files.</p> <ul> <li>Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/sample_spectrograms_BrazilAcre.sh\n</code></pre> <ul> <li>Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/bandpass_filter_decimate_BrazilAcre.sh\n</code></pre> <p>Based on sample spectrograms, filter 3-20 Hz for all 3 channels. Decimate by a factor of 2, to 50 Hz sampling rate. Filtered continuous data files start with Deci2.bp3to20.*, which are input to the fingerprint step.  </p> <ul> <li>Need to add <code>.mseed</code> extension to all time series files, otherwise the Julian day number in the time series file gets removed while fingerprinting, and we cannot tell the difference between fingerprints from different days.  </li> </ul>"},{"location":"ex_params/#092-fingerprint","title":"0.9.2 Fingerprint","text":"<p>Master script to create fingerprints on each channel, then generate global indices at the end:  </p> <pre><code>~/FAST/fingerprint/$ ../parameters/fingerprint/BrazilAcre/run_fp_BrazilAcre.sh\n</code></pre> <p>Example script to generate fingerprints on one channel (HHE) at one station (CZSB), called by the master script run_fp_BrazilAcre.sh:  </p> <pre><code>~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/BrazilAcre/fp_input_BR_CZSB_HHE.json\n    \"fingerprint\": {\n       \"sampling_rate\": 50,\n       \"min_freq\": 3.0,\n       \"max_freq\": 20.0,\n       \"spec_length\": 10.0,\n       \"spec_lag\": 0.2,\n       \"fp_length\": 128,\n         Continuous Data (Network.Station.Channel)\n       \"fp_lag\": 10,\n       \"k_coef\": 800,\n       \"nfreq\": 32,\n       \"mad_sampling_rate\": 0.1,\n       \"mad_sample_interval\": 86400\n    \"data\": {\n       \"station\": \"CZSB\",\n       \"channel\": \"HHE\",\n       \"start_time\": \"15-10-28T00:00:00.0\",\n       \"end_time\": \"16-02-01T00:00:03.0\",\n       \"folder\": \"/lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/\",\n</code></pre> <p>There are a total of 3 <code>fp_input_NETWORK_STATION_CHANNEL.json</code> fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S25.  </p> <p>Table S25: Fingerprint input parameters for BrazilAcre earthquake detection: 3-component at 1 station (Figure 14, yellow triangle), after bandpass filter 3-20 Hz, and decimated to 50 Hz sampling rate. The fingerprint sampling period is dt_fp = 2 seconds.  </p> <p> </p> <p>Median/MAD output files: <code>mad/mad*.txt</code> Fingerprints (binary files): <code>fingerprints/CZSB.HHE.fp</code> Timestamps at each fingerprint index (text files): <code>timestamps/CZSB.HHE.ts</code> </p> <p>Finally, to create global indices for the BrazilAcre data set, so that fingerprint indices from different channels (all 3) and stations are referenced to a common starting time:  </p> <pre><code>$ python global_index.py ../parameters/fingerprint/BrazilAcre/global_indices_BrazilAcre.json\n</code></pre> <p>The common starting time is in global_idx_stats.txt: 2015-10-28T00:00:21.340000 UTC  </p>"},{"location":"ex_params/#093-similarity-search","title":"0.9.3 Similarity Search","text":"<p>Master script to run similarity search on each channel (out of 3 total):  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/run_simsearch_BrazilAcre.sh\n</code></pre> <p>Example script to run similarity search on one channel (HHE) at one station (CZSB), called by the master script <code>run_simsearch_BrazilAcre.sh</code>:  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/filt_simsearch_input_BrazilAcre.sh CZSB HHE\nNTBLS=100\nNHASH=4\nNREPEAT=5\nNVOTES=2\nNTHREAD=56\nNUM_PART=1\n</code></pre> <p>Table S26: Similarity search input parameters for BrazilAcre earthquake detection: 3 channels at 1 station (3 components each).  </p> <p> </p> <p>The same input parameters are used for similarity search on all 3 channels (Table S26).  </p>"},{"location":"ex_params/#094-postprocessing","title":"0.9.4 Postprocessing","text":"<p>First, run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (3 total):  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/output_BrazilAcre_pairs.sh  \n</code></pre> <p>For example, on one channel (HHE) at one station (CZSB), all on one line:  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/\n-p candidate_pairs_CZSB_HHE -i /lfs/1/ceyoon/TimeSeries/BrazilAcre/global_indices/CZSB_HHE_idx_mapping.txt\n</code></pre> <p>Output file for example (large size at channel level): /<code>lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ candidate_pairs_CZSB_HHE_merged.txt</code> </p> <p>Second, run the master script to combine similarity output from all 3 components at a given station, for 1 station:  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/combine_BrazilAcre_pairs.sh\n</code></pre> <p>For example, on three channels (HHE, HHN, HHZ) at one station (CZSB), first move the similarity output text files to the inputs_network/ directory:  </p> <pre><code>$ cd /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/\n$ mv candidate_pairs_CZSB_HH*_merged.txt ../../../inputs_network/\n</code></pre> <p>Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S26). Note: this step will delete the <code>candidate_ pairs_CZSB_HH*_merged.txt</code> files.  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/\n-p candidate_pairs_CZSB --sort true --parse false -c true -t 6\n</code></pre> <p>Output file for example (smaller size at station level): <code>/lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ candidate_pairs_CZSB_combined.txt</code> </p> <p>Finally, detect similar fingerprints across the network of 1 station, using the input parameters in Table S27 (Note: this step only aggregates similar event pairs from similar fingerprints, and resolves the pairs into a list of candidate events, since there is only 1 station.):  </p> <pre><code>~/FAST/postprocessing/$\npython scr_run_network_det.py ../parameters/postprocess/BrazilAcre/1sta_1stathresh_network_params.json\n       \"network\": {\n              \"max_fp\": 4147182,\n              \"dt_fp\": 2.0, (seconds)\n              \"dgapL\": 10, (20 s)\n              \"dgapW\": 3, (6 s)\n              \"num_pass\": 2,\n              \"min_dets\": 3,\n              \"min_sum_multiplier\": 1,\n              \"max_width\": 8, (16 s)\n              \"ivals_thresh\": 6,\n              \"nsta_thresh\": 1,\n              \"input_offset\": 15 (30 s) &lt;--- NOT USED\n},  \n</code></pre> <p>Table S27: Network detection input parameters for BrazilAcre at 1 station. max_fp = 4147182 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 2 seconds is the fingerprint sampling period from Table S25.  </p> <p> </p> <p>Network detection output file: <code>/lfs/1/ceyoon/TimeSeries/BrazilAcre/network_detection/1sta_1stathresh_detlist_rank_by_peaksum.tx</code>t (14,477 events)  </p> <p>At this point, FAST earthquake detection processing is done.  </p>"},{"location":"ex_params/#095-remove-duplicates-after-network-detection","title":"0.9.5 Remove duplicates after network detection","text":"<p>Sort events in descending order of peaksum (peak similarity score between similar fingerprints) for the final detection list.  </p> <pre><code>~/FAST/utils/network/$ ./final_single_station_sort_nsta_peaksum.sh\n</code></pre> <p>Output: <code>sort_peaksum_1sta_1stathresh_CZSB_events.txt</code> (14,477 events)  </p>"},{"location":"ex_params/#096-visual-inspection-and-final-detections","title":"0.9.6 Visual inspection and final detections","text":"<p>Plot event waveforms in the final detection list, ranked in descending order of peaksum (peak similarity score between similar fingerprints), for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (peaksum \u2265 6).  </p> <pre><code>~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_BrazilAcre.py 0 14477\n</code></pre> <p>Output: <code>.png</code> image files in <code>1sta_1stathresh_NetworkWaveformPlots/</code> (zip file)  </p> <p>Visual inspection shows that there are many false detections that do not look like earthquake waveforms (for example, <code>event_rank00000_peaksum116351_ind854248_time1708496.0_2015-11-16T18/35/17.340000.png</code>). However, some earthquake waveforms (for example, <code>event_rank00049_peaksum26898_ind1297608_time2595216</code>. <code>0_2015-11-27T00/53/57.340000.png</code>) are also detected. I suggest running FAST on at least 3 stations for reliable earthquake detection. </p> <p>14,474 events are above the arbitrary low threshold (peaksum \u2265 6).  </p> <ul> <li><code>EQ_sort_peaksum_1sta_1stathresh_CZSB_events.txt</code> </li> </ul> <p>For the 14,474 events, output a catalog-like formatted list:  </p> <pre><code>~/FAST/utils/events/$ python output_final_detection_list.py\n</code></pre> <p>Output: <code>FINAL_Detection_List_BrazilAcre_1sta_1stathresh_peaksum6.txt</code> (14,474 events)  </p>"},{"location":"ex_params/#010-new-zealand-year-2010","title":"0.10 New Zealand, Year 2010","text":"<p>Info</p> <p>The objective of this study is to detect small earthquakes in New Zealand to test earthquake triggering hypothesis. Detection results, with input parameters, are described in Rong et al. [2018]. 1 year continuous data (2010), 5 seismic stations LTZ, MQZ, KHZ, THZ, OXZ (Figure 16, black triangles), vertical components only, sampled at 100 Hz. Detections were compared against the GeoNet catalog, and visually inspected. FAST detected 11419 events: 4916 catalog events (Figure 16, red circles), 355 teleseismic events, 6123 new local earthquakes and 25 false positives (noise waveforms).  </p> <p> </p> Figure 16: New Zealand map: 5 stations (black triangles) used for FAST detection (except GVZ which was not used), and locations of GeoNet catalog events (circles). 4916 catalog events were detected by FAST (red circles). Catalog events missed by FAST are displayed as green circles."},{"location":"ex_params/#011-calipatria-june-2021","title":"0.11 Calipatria, June 2021","text":""},{"location":"ex_params_intro/","title":"0.1 Introduction","text":"<p>FAST is available to the public at https://github.com/stanford-futuredata/FAST as open-source software, and it will be released with a comprehensive user manual containing guidance for setting parameters. Interested users can run FAST to perform an uninformed search for earthquakes with similar waveforms on any seismic network, with varying duration of continuous data and number of stations. The FAST software has successfully detected earthquakes in the following data sets. FAST will only reach its full potential as a tool for seismological discovery if other users apply it to their own data sets (filling the N and T gaps in Figure 1) and improve the detection algorithms. Thank you to all collaborators and interested users who shared data, which was useful for testing the FAST software and identifying bug fixes, in preparation for its public release.  </p> <p> </p> Figure 1: Dimensions of different data sets where FAST has successfully detected similar earthquakes. The log-scale axes represent the directions of data growth in seismology to \u201dlarge-T\u201d and \u201dlarge-N\u201d big data sets (Chapters 1 and 5): T is the longest duration of continuous data over all stations in the data set, while N is the number of seismic stations in the data set. Blue stars: data sets from Chapters 2-5. Red stars: additional data sets from Appendix A, Sections A.1-A.6."},{"location":"f_p/","title":"Fingerprint","text":""},{"location":"f_p/#feature-extraction-overview","title":"Feature Extraction Overview","text":""},{"location":"f_p/#step-1-time-series-spectrogram","title":"Step 1: Time Series --&gt; Spectrogram","text":""},{"location":"f_p/#step-2-spectrogram-spectral-images","title":"Step 2: Spectrogram --&gt; Spectral Images","text":"<ul> <li>To find short duration events, divide spectrogram into overlapping spectral images  <ul> <li>Long lag --&gt; fewer spectral images to compare --&gt; fast</li> </ul> </li> </ul>"},{"location":"f_p/#step-3-spectral-image-wavelet-transform","title":"Step 3: Spectral Image --&gt; Wavelet Transform","text":"<ul> <li>Goal: compress nonstationary seismic signal  <ul> <li>Compute 2D discrete wavelet transform (Haar basis) of spectral image to get wavelet coefficients</li> </ul> </li> </ul>"},{"location":"f_p/#step-4-spectrogram-spectral-images","title":"Step 4: Spectrogram --&gt; Spectral Images","text":"<ul> <li>Key discriminative features are concentrated ina few wavelet coefficients with highest deviation  <ul> <li>Deviation defined by median/MAD over entire data set</li> <li>Keep only sign (+ or -) of these coefficients, set rest to 0</li> </ul> </li> <li>Data compression, robust to noise</li> </ul>"},{"location":"f_p/#step-5-spectrogram-spectral-images","title":"Step 5: Spectrogram --&gt; Spectral Images","text":"<ul> <li>Fingerprint must be compact and sparse to store in database  <ul> <li>Convert top coefficients to a binary sequence of 0\u2019s, 1\u2019s<ul> <li>Negative: 01, Zero: 00, Positive: 10</li> </ul> </li> </ul> </li> </ul>"},{"location":"f_p/#how-do-we-measure-similarity","title":"How do we measure similarity?","text":""},{"location":"f_p/#fingerprint-parameters","title":"Fingerprint Parameters","text":"<pre><code>{\n    \"fingerprint\": {\n        \"sampling_rate\": 20,                # Sampling rate (Hz)\n        \"min_freq\": 0.0,                    # Bandpass frequency (Hz) - minimum\n        \"max_freq\":, 10.0,                  # Bandpass frequency (Hz) \u2013 maximum\n        \"spec_length\": 6.0,                 # Time window length (s) for spectrogram\n        \"spec_lag\": 0.2,                    # Time window lag (s) for spectrogram\n        \"fp_length\": 32,                    # Spectral image length (samples)\n        \"fp_lag\": 5,                        # Spectral image lag (samples)\n        \"k_coef\": 200,                      # Number of wavelet coefficients to keep\n        \"nfreq\": 32,                        # Final spectral image width (samples)\n        \"mad_sampling_rate\": 1,             # Median/MAD sampling fraction of data\n        \"mad_sampling_interval\": 86400      # Median/MAD sampling frequency (s)\n    }\n}\n</code></pre> <p>Note</p> <p>Need one input file per component at each station: <pre><code>parameters/fingerprint/fp_input_${NETWORK}_${STATION}_${CHANNEL}.json\n</code></pre> Example: <code>fp_input_CI_CDY_EHZ.json</code> </p>"},{"location":"f_p/#how-to-select-bandpass-filter","title":"How to select bandpass filter?","text":"<ul> <li>Filter can be different for different stations and components  </li> <li>Contain as much of your desired earthquake signal as possible; not too narrowband  </li> <li>Remove frequencies with repeated noise: important </li> <li>View sample spectrograms to empirically determine these noisy frequencies (output as .png image files):  </li> </ul> <pre><code>parameters/preprocess_utils/sample_spectrograms_daily _NEP.py\n</code></pre> <ul> <li>Twice a day (day and night: cultural noise variations)</li> <li> <p>Once a month or once a day \u2013 sample randomly</p> </li> <li> <p>Usually 0-2 Hz has repeated noise; sometimes &gt;20 Hz</p> </li> <li> <p>Without this step, similar noise signals will dominate your detections --&gt; you will not find earthquakes </p> </li> <li> <p>May want to avoid teleseismic event detection</p> <ul> <li>Lower limit 3-4 Hz</li> </ul> </li> <li> <p>4-12 Hz generally works well as default</p> </li> </ul>"},{"location":"f_p/#example-bandpass-filter-selection-given-sample-spectrogram","title":"Example: Bandpass filter selection, given sample spectrogram","text":"<pre><code>\"spec_length\": 6.0,     # Time window length (s) for spectrogram\n\"spec_lag\": 0.2,        # Time window lag (s) for spectrogram\n\"fp_length\": 32,        # Spectral image length (samples)\n\"fp_lag\": 5,             # Spectral image lag (samples)\n</code></pre> <p>Info</p> <p>Spectral image (and fingerprint) length: 12.4 seconds Spectral image (and fingerprint) lag: 1 second  </p> <ul> <li> <p>Choose parameters so that entire earthquake waveform (P,S,coda) fits into <code>fp_length</code> time window  </p> <ul> <li>Not too short (just P or S arrival), but not too long (otherwise adds noise)  </li> <li>Choose same parameters for all components at all stations  </li> <li>Adjust <code>spec_length</code> and <code>fp_length</code> values  </li> <li><code>fp_length</code> (samples) should be a power of 2  <ul> <li>Required for the wavelet transform. If <code>fp_length</code> is not a power of 2, each spectral image will be downsampled to the next smallest power of 2.  </li> </ul> </li> </ul> </li> <li> <p><code>spec_lag</code> should be short with &gt;95% overlap between adjacent time windows; 0.05 to 0.2 seconds is a good default  </p> </li> <li><code>fp_lag</code>: can be slightly longer with &gt;85% overlap between adjacent spectral images; 0.5 to 2 seconds is a good default  </li> </ul> <p> </p> <pre><code>\"k_coef\": 200,      # Number of wavelet coefficients to keep  \n\"nfreq\": 32,        # Final spectral image width (samples)  \n</code></pre> <ul> <li>Spectral image width will be resized (usually downsampled) to <code>nfreq</code> samples  <ul> <li>Initial spectral image width is 2(<code>spec_length</code>)(<code>max_freq</code> - <code>min_freq</code>) samples: depends on bandpass filter  </li> <li><code>nfreq</code> must be a power of 2 for wavelet transform; 32 is good default value  </li> </ul> </li> <li>Each spectral image (and wavelet-transform) has dimensions = <code>nfreq</code> * <code>fp_length</code> <ul> <li>This example: 32*32 = 1024 elements  </li> </ul> </li> <li>To set <code>k_coef</code>, keep ~20% of most anomalous wavelet coefficients  <ul> <li>This example: 200/1024 ~ 19.5%</li> </ul> </li> <li>Fingerprint has twice as many elements as spectral image  <ul> <li>This example: 2 * 1024 = 2048 elements  </li> </ul> </li> </ul>"},{"location":"f_p/#fast-fingerprints-sparsity-parameter","title":"FAST Fingerprints: Sparsity Parameter","text":"<pre><code>\"mad_sampling_rate\": 1,          # Median/MAD sampling fraction of data\n\"mad_sample_interval\": 86400,    # Median/MAD sampling interval (s)\n</code></pre> <ul> <li>For each coefficient, compute median/MAD statistics over entire data set. This step determines which <code>k_coef</code> wavelet coefficients to keep.  <ul> <li>But if data set is too long (months-years), compute statistics over a representative sample of data  </li> </ul> </li> <li><code>mad_sampling_rate</code>: fraction of entire continuous data set used to compute median/MAD  <ul> <li>Duration of sampled data set = (<code>mad_sampling_rate</code>) * (continuous data duration) should not exceed 1 week, otherwise may not fit in memory</li> </ul> </li> <li>Retrieve sample of data for median/MAD statistics once per <code>mad_sample_interval</code> <ul> <li>86400 s = 1 day is a good default value</li> <li>Exact time of sample is determined randomly: expect different numbers every time you run this</li> </ul> </li> <li> <p>Median/MAD for each coefficient: pre-computed and stored in a text file, then read in during fingerprint generation  </p> <ul> <li><code>data/waveforms${STATION}/mad/mad*.txt</code> </li> </ul> </li> <li> <p>Rule of thumb</p> <ul> <li>Duration &lt;1 week: set to 1 (use entire data set for sample)</li> <li>Duration weeks \u2013 months: set to 0.1 (sample 10% of data)</li> <li>Duration &gt;1 year: set to 0.01 (sample 1% of data)</li> </ul> </li> <li> <p>Runtime-accuracy tradeoff</p> </li> </ul> <p> </p> <pre><code>\"performance\": {\n    \"num_fp_thread\": 8,         # Number of parallel processes  \n    \"partition_len\": 86400      # Continuous data partition (s)  \n},\n</code></pre> <ul> <li> <p>Can generate fingerprints in parallel by setting <code>num_fp_thread</code> &gt; 1  </p> <ul> <li>Each process gets one continuous data file<ul> <li>Better parallelization if you have one mseed file per day, rather than one per month</li> </ul> </li> </ul> </li> <li> <p>Generate fingerprints <code>partition_len</code> at a time  </p> <ul> <li>86400 s (1 day) is a good default value  </li> </ul> </li> <li> <p>Changing these \u201cperformance\u201d parameters should not affect the final results  </p> </li> </ul> <pre><code>\"data\": {\n    \"station\": \"CDY\",  \n    \"channel\": \"EHZ\",  \n    \"start_time\": \"99-10-15T13:00:00.0\",                    # Time format: YY-MM-DDTHH:MM:SS.S  \n    \"end_time\": \"99-10-16T09:46:44.0\",  \n    \"folder\": \"../data/waveformsCDY/\",                      # folder with input data  \n    \"fingerprint_files\": [                                  # Usually finerprint_files, MAD_samples_files should be the same; can have list of multiple files for input continuous data\n        \"Deci5.Pick.19991015130000.CI.CDY.EHZ.sac\"],  \n        \"MAD_sample_files\": [  \n            \"Deci5.Pick.19991015130000.CI.CDY.EHZ.sac\"]  \n}\n</code></pre> <ul> <li>OUTPUTS <ul> <li><code>${folder}/fingerprints/</code> <ul> <li>Fingerprints from each continuous data file (can delete these later): <code>fp_*</code> </li> <li>Single file with all fingerprints: <code>${STATION}.${CHANNEL}.fp</code> </li> <li>For example: <code>data/waveformsCDY/fingerprints/CDY.EHZ.fp</code> </li> </ul> </li> <li><code>${folder}/timestamps/</code><ul> <li>Timestamp (YYYY-MM-DDTHH:MM:SS.SSS) for each fingerprint</li> <li>Timestamps from each continuous data file (used later for global index calculation): <code>ts_*</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"f_p/#global-index-inputs-outputs","title":"Global Index: Inputs &amp; Outputs","text":"<ul> <li>Input file: <code>global_indices.json</code> </li> </ul> <pre><code>{\n    \"index_folder\": \"../data/global_indices/\",                              # Output folder\n    \"fp_param_dir\": \"../parameters/fingerprint/\",                           # Input folder\n    \"fp_params\": [\"fp_input_CI_TPC_EHZ.json\", \"fp_input_CI_RMR_EHZ.json\",   # Fingerprint input files for all components and stations to use for detection\n    \"fp_input_CI_RMM_EHZ.json\u201d, \"fp_input_CI_HEC_BHE.json\u201c, \n    \"fp_input_CI_HEC_BHN.json\", \"fp_input_CI_HEC_BHZ.json\u201c, \n    \"fp_input_CI_CPM_EHZ.json\", \"fp_input_CI_GTM_EHZ.json\", \n    \"fp_input_CI_CDY_EHZ.json\"]\n}\n</code></pre> <ul> <li>Outputs:<ul> <li>Global start time \u201ct0\u201d for index 0 (YYYY-MM-DD THH:MM:SS.SSS), fingerprint input file names: <code>global_idx_stats.txt</code> </li> <li>Global index files for each channel, containing global index of each fingerprint: <code>${STATION}_${CHANNEL}_idx_mapping.txt</code></li> </ul> </li> </ul>"},{"location":"f_p/#sample-fingerprint-parameters","title":"Sample Fingerprint Parameters","text":"<p>Find a sample fingerprint parameters json file here.  </p> <p>You can duplicate this file for each component and change the parameters as needed. You must edit the data section of the file and change the filename for each component.  </p> <p>Follow the file naming convention: <code>fp_input_NETWORK_STATION_CHANNEL.json</code> </p> <p>Example fingerprint parameter settings:  </p> <pre><code>  {\n    \"fingerprint\": {                (fingerprint settings)\n        \"sampling_rate\": 100,         (sampling rate in Hz)\n        \"min_freq\": 2.0,              (min bandpass frequency in Hz)\n        \"max_freq\": 20.0,             (max bandpass frequency in Hz)\n        \"spec_length\": 6.0,           (length of spectrogram window in seconds)\n        \"spec_lag\": 0.2,              (lag between neighboring spectrogram windows in seconds)\n        \"fp_length\": 128,             (fingerprint length in samples)\n        \"fp_lag\": 10,                 (fingerprint lag in samples)\n        \"k_coef\": 1600,               (number of top haar wavelet coefficients to keep)\n        \"nfreq\": 32,                  (number of frequency / time bins in fingerprints \n                                       (must be power of 2))\n        \"mad_sampling_rate\": 0.1,     (sampling rate for calculating MAD statistics)\n        \"mad_sample_interval\": 14400  (sampling interval for calculating MAD statistics in seconds)\n    },\n\n    \"performance\": {               (performance settings)\n        \"num_fp_thread\": 12,          (number of threads)\n        \"partition_len\": 28800        (fingerprint partition length in seconds)\n    },\n\n    \"data\": {                      (data settings)\n        \"station\": \"KHZ\",\n        \"channel\": \"HHZ\",\n        \"start_time\": \"10-01-01T00:00:00.0\",\n        \"end_time\": \"10-06-01T00:00:00.0\",\n        \"folder\": \"../bp2to20_waveformsKHZ/\",\n        \"fingerprint_files\": [\n            \"bp2to20.NZ.KHZ.10.HHZ__20100101T000000Z__20100201T000000Z.mseed\",\n            \"bp2to20.NZ.KHZ.10.HHZ__20100201T000000Z__20100301T000000Z.mseed\",\n            \"bp2to20.NZ.KHZ.10.HHZ__20100301T000000Z__20100401T000000Z.mseed\",\n            \"bp2to20.NZ.KHZ.10.HHZ__20100401T000000Z__20100501T000000Z.mseed\",\n            \"bp2to20.NZ.KHZ.10.HHZ__20100501T000000Z__20100601T000000Z.mseed\"],\n        \"MAD_sample_files\": [\n            \"bp2to20.NZ.KHZ.10.HHZ__20100101T000000Z__20100201T000000Z.mseed\",\n            \"bp2to20.NZ.KHZ.10.HHZ__20100201T000000Z__20100301T000000Z.mseed\",\n            \"bp2to20.NZ.KHZ.10.HHZ__20100301T000000Z__20100401T000000Z.mseed\",\n            \"bp2to20.NZ.KHZ.10.HHZ__20100401T000000Z__20100501T000000Z.mseed\",\n            \"bp2to20.NZ.KHZ.10.HHZ__20100501T000000Z__20100601T000000Z.mseed\"]\n    }\n}\n</code></pre>"},{"location":"f_p/#fingerprint-examples-from-github","title":"Fingerprint Examples from GitHub","text":"<p>Click here for more example fingerprint parameters such as:  </p> <p> </p> <p>Info</p> <p>File can be found in <code>FAST/parameters/fingerprint/fp_input_CI_CDY_EHZ.json</code> </p> <p>Click here for an example fingerprint script such as:  </p> <p> </p> <p>Info</p> <p>File can be found in <code>FAST/parameters/fingerprint/run_fp_HectorMine.sh</code> </p>"},{"location":"fast_overview/","title":"FAST Overview","text":""},{"location":"fast_overview/#what-is-fast","title":"What is FAST?","text":"<p>FAST is an end-to-end and unsupervised earthquake detection pipeline\u2014it does not require any examples of known event waveforms or waveform characteristics for detection. This allows FAST to discover new earthquake sources, even if template waveforms (training data) is not available. It takes continuous seismic data from multiple stations as input and outputs a list of time stamps for potential detections. FAST draws on techniques used by content-based audio recognition systems (like the Shazam app, or Google's Waveprint algorithm), and adapts these methods for the unique characteristics of seismic waveform data.</p> <p></p> <p>FAST was designed to complement existing energy-based detection methods like STA/LTA in order to find previously unknown earthquakes, especially small earthquakes, in seismic data. </p> <p></p> <p>  The image to the right gives an overview of the FAST pipeline, which involves gathering continuous seismic data, preprocessing the data with a bandpass filter, running FAST for feature extraction to get binary fingerprints, running a similarity search with MinHash and Locality Sensitive Hashing, post-processing to identify events and clean up the data, and outputting the detection results.</p> <p> </p>"},{"location":"fast_overview/#standard-earthquake-detection-stalta","title":"Standard Earthquake Detection (STA/LTA)","text":"<p>Ratio: Short Term Average / Long Term Average</p> <p>Traditionally, an earthquake is detected at one station at a time, using an energy detector such as a short-term average (STA)/long-term average (LTA). STA/LTA computes the ratio of the STA energy in a short time window to the LTA energy in a longer time window, as these windows slide through the continuous data. A detection is declared when the STA/LTA ratio exceeds certain thresholds. An association algorithm then determines whether detections at multiple stations across the network are consistent with a seismic source. If a seismic event is detected at a minimum of four stations, it is included in an earthquake catalog, which is a database of the location, origin time, and magnitude of known earthquakes.</p> <p>STA/LTA successfully identifies earthquakes with impulsive, high signal-to-noise ratio (snr) P-wave and S-wave arrivals presented below. </p> <p></p> <p>STA/LTA rates high on general applicability, which we define as the ability to detect a wide variety of earthquakes without prior knowledge of the event waveform or source information. But STA/LTA fails to detect earthquakes, or may produce false detections, in more challenging situations such as low snr, waveforms with emergent arrivals, overlapping events, cultural noise, and sparse station spacing; thus, STA/LTA has low detection sensitivity as shown below. </p> <p></p> <p>Therefore, earthquake catalogs are incomplete for lower-magnitude events. Read more here.</p>"},{"location":"fast_overview/#waveform-similarity","title":"Waveform Similarity","text":"<p>Many algorithms have been developed to efficiently search for similar items in massive data sets; applications include identifying similar files in a large file system, finding near-duplicate Web pages, detecting plagiarism in documents, and recognizing similar audio clips for music identification, such as in the Shazam mobile app. We can meet our objective of a fast, efficient, automated blind detection of similar earthquake waveforms in huge volumes of continuous data by leveraging scalable algorithms that are widely used in the computer science community. Seismologists are just beginning to exploit data-intensive search technologies to analyze seismograms; one recent application is an earthquake search engine for fast focal mechanism identification that retrieves a best-fit synthetic seismogram from a large database, whereas another study developed a fast-approximation algorithm to find similar event waveforms within large catalogs.</p> <p>Rather than directly comparing waveforms, we first perform feature extraction to condense each waveform into a compact \u201cfingerprint\u201d that retains only its key discriminative features. A fingerprint serves as a proxy for a waveform; thus, two similar waveforms should have similar fingerprints, and two dissimilar waveforms should have dissimilar fingerprints. We assign the fingerprints (rather than waveforms) to LSH hash buckets.  </p> <p>If you are interested in learning more about Locality Sensitive Hashing (LSH), check out \"Locality Sensitive Hashing (LSH) for Search with Shingling + MinHashing (Python)\" by James Briggs on YouTube.</p> <p>Our approach, an algorithm that we call Fingerprint And Similarity Thresholding (FAST), builds on the Waveprint audio fingerprinting algorithm, which combines computer-vision techniques and large-scale data processing methods to match similar audio clips. We modified the Waveprint algorithm based on the properties and requirements of our specific application of detecting similar earthquakes from continuous seismic data. We chose Waveprint for its demonstrated capabilities in audio identification and its ease of mapping the technology to our application.  </p> <p>First, an audio signal resembles a seismogram in several ways: they are both continuous time series waveform data, and the signals of interest are often nonimpulsive. Second, Waveprint computes fingerprints using short overlapping audio clips, as in autocorrelation. Third, Waveprint takes advantage of LSH to search through only a small subset of fingerprints. Waveprint also reports fast retrieval results with high accuracy, and its feature extraction steps are easily parallelizable. FAST scores high on three qualitative desirable metrics for earthquake detection methods (detection sensitivity, general applicability, and computational efficiency), whereas other earthquake detection algorithms (STA/LTA, template matching, and autocorrelation) do well on only two of the three.  </p> <p></p> Waveform similarity allows detection of smaller earthquakes. <p></p> <p></p> A comprehensive, exhaustive search for earthquakes with similar waveforms."},{"location":"fast_overview/#efficient-search","title":"Efficient Search","text":"<p>FAST identifies candidate earthquake waveforms using a blind search for similar waveforms in single-channel continuous ground motion data. Rather than using a brute-force search in the time domain, as in the autocorrelation method (Brown et al., 2008), FAST searches for similar waveform fingerprints using an efficient indexing and search procedure.</p> <p>The FAST similarity search involves two steps: the first is indexing a set of database fingerprints, and the second is querying the index to identify similar waveform fingerprints. Because FAST assumes no prior information about waveform signatures, we set up the similarity search in a manner that will identify any repeating or similar signals among the full set of waveform fingerprints. Therefore, in FAST similarity search we store the full set of fingerprints in the search index and we also use the full set of fingerprints as queries against the index, in a true blind search. The index is designed such that for each query fingerprint, FAST can identify similar fingerprints without having to scan the entire index. Rather than an exhaustive search, FAST performs an approximate similarity search, guaranteed to identify similar waveforms with high probability, which enables improved scalability and reduced runtime.</p> <p></p> Efficient search for similar items in large databases <p></p>"},{"location":"fast_overview/#what-can-and-cant-fast-do","title":"What can and can't FAST do?","text":"<p>Typical use cases of FAST include weeks, months, or years of continuous seismic data at several stations, which FAST scans through to find small similar (or repeating) earthquakes.</p> <p>FAST will not detect an earthquake that occurs only once and is not similar enough to any other earthquakes in your continuous data set.</p> <p>Most similar earthquakes != largest earthquakes. </p> <ul> <li>Larger earthquakes often match a smaller earthquake on the coda, so they are detected with lower similarity (or not detected at all).</li> </ul> <p>FAST is intended to complement (not replace) existing energy-based detection methods like STA/LTA.</p>"},{"location":"get_seismic_data/","title":"Getting Seismic Data","text":"<p>Using Obspy, users can download seismic data with <code>get_waveforms</code> or mass downloader.  </p> <p>Example using <code>get_waveforms</code>: <pre><code>from obspy import UTCDateTime\nfrom obspy import Stream\nfrom obspy import read\nfrom obspy.clients.fdsn import Client\nimport os\nimport json\n\nt = UTCDateTime(2021, 6, 5, 10, 55, 58) # largest event time\n\nstart_time = UTCDateTime(\"2021-06-05 00:00:00\")\nend_time = UTCDateTime(\"2021-06-06 00:00:00\")\n\n# Earthquake longitude, latitude, depth\nlon = -115.635\nlat = 33.140\ndepth = 5.8\n\nchan_priority_list=[\"HHZ\", \"HHN\", \"HHE\", \"HH1\", \"HH2\",\n                    \"BHZ\", \"BHN\", \"BHE\", \"BH1\", \"BH2\",\n                    \"EHZ\", \"EHN\", \"EHE\", \"EH1\", \"EH2\",\n                    \"HNZ\", \"HNN\", \"HNE\", \"HN1\", \"HN2\"]\n\n# Clients to get waveforms\nclient1 = Client(\"IRIS\")\nclient2 = Client(\"SCEDC\")\n\n# Get stations from IRIS within 50km from the earthquake\nIRIS_inventory = client1.get_stations(\n    starttime=start_time, endtime=end_time,\n    longitude=lon, latitude=lat, maxradius=0.5)\n\n# Get stations from SCEDC within 50km from the earthquake\nSCEDC_inventory = client2.get_stations(\n    starttime=start_time, endtime=end_time,\n    longitude=lon, latitude=lat, maxradius=0.5)\n\n# Get dictionary containing the contents of the objects\nIRIS_contents = IRIS_inventory.get_contents()\nSCEDC_contents = SCEDC_inventory.get_contents()\n\n# File format\nstart_time_file = (f\"{start_time.year}{str(start_time.month).zfill(2)}{str(start_time.day).zfill(2)}T{str(start_time.hour).zfill(2)}{str(start_time.minute).zfill(2)}{str(start_time.second).zfill(2)}Z\")\nend_time_file = (f\"{end_time.year}{str(end_time.month).zfill(2)}{str(end_time.day).zfill(2)}T{str(end_time.hour).zfill(2)}{str(end_time.minute).zfill(2)}{str(end_time.second).zfill(2)}Z\")\n\n# Get waveforms from IRIS\nos.mkdir(\"waveforms_IRIS\")\nst_list = []\nfor i in IRIS_contents[\"stations\"]:\n    curr = i.split()\n\n    network = curr[0].split('.')[0]\n    station = curr[0].split('.')[1]\n    try:\n        wave_form = client1.get_waveforms(network, station, \"*\", \"*\", start_time, end_time)\n\n    except:\n        print(f\"No data available for {network}.{station}\")\n\n    for s in wave_form:\n\n        if s.stats.channel in chan_priority_list:\n            s.write(f\"waveforms_IRIS/{s.stats.network}.{s.stats.station}.{s.stats.channel}__{start_time_file}__{end_time_file}.mseed\", format=\"MSEED\")\n\n            if s.stats.station not in st_list:\n                st_list.append(s.stats.station)\n\n# Get waveforms from SCEDC\nos.mkdir(\"waveforms_SCEDC\")\nst_list = []\nfor i in SCEDC_contents[\"stations\"]:\n    curr = i.split()\n\n    network = curr[0].split('.')[0]\n    station = curr[0].split('.')[1]\n\n    try:\n        wave_form = client2.get_waveforms(network, station, \"*\", \"*\", start_time, end_time)\n\n    except:\n        print(f\"No data available for {network}.{station}\")\n\n    for s in wave_form:\n\n        if s.stats.channel in chan_priority_list:\n            s.write(f\"waveforms_SCEDC/{s.stats.network}.{s.stats.station}.{s.stats.channel}__{start_time_file}__{end_time_file}.mseed\", format=\"MSEED\")\n\n            if s.stats.station not in st_list:\n                st_list.append(s.stats.station)\n</code></pre></p> <p>Example using mass downloader: <pre><code>import os\nimport obspy\nfrom obspy.clients.fdsn.mass_downloader import CircularDomain, \\\n    Restrictions, MassDownloader\n\n# Earthquake origin time\norigin_time = obspy.UTCDateTime(2021, 6, 5, 10, 55, 58)\n\n# Set up a circular domain with a maximum radius of 50km\ndomain = CircularDomain(latitude=33.140, longitude=-115.635, minradius=0, maxradius=0.5)\n\n# Make directories to save miniseed waveform files and station information\nos.makedirs(\"waveforms_mdl\")\nos.makedirs(\"stations_mdl\")\n\n# Add restrictions to downloaded data such as start time, end time, and channel priorities\nrestrictions = Restrictions(\n    starttime = obspy.UTCDateTime(\"2021-06-05 00:00:00\"),\n    endtime = obspy.UTCDateTime(\"2021-06-06 00:00:00\"),\n    reject_channels_with_gaps=True,\n    minimum_length=0,\n    channel_priorities=[\"HH[ZNE12]\", \"BH[ZNE12]\", \"EH[ZNE12]\", \"HN[ZNE12]\"])\n\n# Select Clients to get waveforms from\nmdl = MassDownloader(providers=[\"IRIS\", \"SCEDC\"])\n\nmdl.download(domain, restrictions, mseed_storage=\"waveforms_mdl\",\n             stationxml_storage=\"stations_mdl\")\n</code></pre></p> <p>After saving waveforms to your directory, there may be multiple channels for one stations. </p> <p>In the image shown above, there are multiple channels for CI.BOM, CI.CLI2, and CI.COK2. You do not need all of the channels. Instead, refer to this priority list to know which channels to keep for running FAST:  </p> <ol> <li>HH: High Broad Band; Sampling rate 100x per second</li> <li>BH: Broad Band; Sampling rate 40x per second</li> <li>EH: Extremely Short Period</li> <li>HN: Measures how much the ground movement is accelerating; not good for finding small earthquakes  </li> </ol> <p>Read more here.</p> <p>If you have HH channels available, choose those. Otherwise, use BH. If you don't have BH, then use EH. Lastly, if only HN is available, then use HN.  </p> <p></p>"},{"location":"groningen_dataset/","title":"0.8 Groningen Data Set","text":"<ul> <li>Location: Netherlands (gas production field)  </li> <li>Duration: 4 months (119 days): 2018-01-01 to 2018-04-30  </li> <li>Network: 67 stations (Figure 12), 3 components each (HH1, HH2, HHZ) = 201 channels. (Station G294 not used for detection due to short duration)  </li> <li>Sampling rate: 20 Hz (already downsampled)  </li> <li>Provided by: Zack Spica (Stanford Geophysics)  </li> </ul> Figure 12: Groningen map provided by Zack Spica: 67 stations (black, red triangles) used for FAST detection, and locations of known catalog events (blue circles)."},{"location":"groningen_dataset/#081-preprocessing","title":"0.8.1 Preprocessing","text":"<ul> <li>Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/continuous_data_times_Groningen.sh\n</code></pre> Figure 13: Duration of Groningen continuous data at 67 stations (change colors with each station), 3 components each. White sections indicate time gaps. <p>The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_Groningen.py to plot the duration of available continuous data at each station and channel (Figure 13).  </p> <ul> <li>Confirmed no zero-filled time-gap sections of continuous data in all 201 channels (need to modify paths in fill_time_gaps_with_uncorrelated_noise.py):  </li> </ul> <p><pre><code>~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py\n</code></pre> Use original mseed data files. </p> <ul> <li>Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/sample_spectrograms_Groningen.sh\n</code></pre> <ul> <li>Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/bandpass_filter_decimate_Groningen.sh\n</code></pre> <p>Based on sample spectrograms, filter 3-10 Hz for all 201 channels. No need to decimate, as sampling rate is already low at 20 Hz. Filtered continuous data files start with Deci1.bp3to10.*, which are input to the fingerprint step.  </p>"},{"location":"groningen_dataset/#082-fingerprint","title":"0.8.2 Fingerprint","text":"<p>Master script to create fingerprints on each channel, then generate global indices at the end:  </p> <p><pre><code>~/FAST/fingerprint/$ ../parameters/fingerprint/Groningen/run_fp_Groningen.sh\n</code></pre> Example script to generate fingerprints on one channel (HHZ) at one station (G014), called by the master script run_fp_Groningen.sh: </p> <pre><code>~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/Groningen/fp_input_NL_G014_HHZ.json\n    \"fingerprint\": {\n       \"sampling_rate\": 20,\n       \"min_freq\": 3.0,\n       \"max_freq\": 10.0,\n       \"spec_length\": 6.0,\n       \"spec_lag\": 0.12,\n       \"fp_length\": 64,\n       \"fp_lag\": 10,\n       \"k_coef\": 400,\n       \"nfreq\": 32,\n       \"mad_sampling_rate\": 0.05,\n       \"mad_sample_interval\": 86400\n    \"data\": {\n       \"station\": \"G014\",\n       \"channel\": \"HHZ\",\n       \"start_time\": \"18-01-01T00:00:00.0\",\n       \"end_time\": \"18-04-30T00:00:00.0\",\n       \"folder\": \"/lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/\",\n</code></pre> <p>There are a total of 201 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S21.  </p> <p>Table S21: Fingerprint input parameters for Groningen earthquake detection: 3-component at 67 stations (Figure 12, red, black triangles), after bandpass filter 3-10 Hz, and sampled at 20 Hz. The fingerprint sampling period is dt_fp = 1.5 seconds.  </p> <p> </p> <p>Median/MAD output files: <code>mad/mad*.txt</code> Fingerprints (binary files): <code>fingerprints/G014.HHZ.fp</code> Timestamps at each fingerprint index (text files): <code>timestamps/G014.HHZ.ts</code> </p> <p>Finally, to create global indices for the Groningen data set, so that fingerprint indices from different channels (all 201) and stations are referenced to a common starting time:  </p> <pre><code>$ python global_index.py ../parameters/fingerprint/Groningen/global_indices_Groningen.json  \n</code></pre> <p>The common starting time is in <code>global_idx_stats.txt</code>: 2018-01-01T00:00:04.500000 UTC </p>"},{"location":"groningen_dataset/#083-similarity-search","title":"0.8.3 Similarity Search","text":"<p>Master script to run similarity search on each channel (out of 201 total):  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/Groningen/run_simsearch_Groningen.sh\n</code></pre> <p>Table S22: Similarity search input parameters for Groningen earthquake detection: 201 channels at 67 stations (3 components each).  </p> <p> </p> <p>Example script to run similarity search on one channel (HHZ) at one station (G014), called by the master script run_simsearch_Groningen.sh: </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/Groningen/filt_simsearch_input_Groningen.sh G014 HHZ\nNTBLS=100\nNHASH=5\nNREPEAT=5\nNVOTES=2\nNTHREAD=56\nNUM_PART=1\nFREQ_NOISE=0.01\n</code></pre> <p>Similarity search is run with the occurrence filter (FREQ_NOISE=0.01) for all 201 channels. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. The same input parameters are used for similarity search on all 201 channels (Table S22).  </p>"},{"location":"groningen_dataset/#084-postprocessing","title":"0.8.4 Postprocessing","text":"<p>First, run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (201 total):  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/output_Groningen_pairs.sh\n</code></pre> <p>For example, on one channel (HHZ) at one station (G014), all on one line:  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/\n-p candidate_pairs_G014_HHZ -i /lfs/1/ceyoon/TimeSeries/Groningen/global_indices/G014_HHZ_idx_mapping.txt\n</code></pre> <p>Output file for example (large size at channel level): <code>/lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/ fingerprints/candidate_pairs_G014_HHZ_merged.txt</code> </p> <p>Second, run the master script to combine similarity output from all 3 components at a given station, for all 67 stations:  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/combine_Groningen_pairs.sh\n</code></pre> <p>For example, on three channels (HH1, HH2, HHZ) at one station (G014), first move the similarity output text files to the inputs_network/ directory:  </p> <pre><code>$ cd /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/\n$ mv candidate_pairs_G014_HH*_merged.txt ../../../inputs_network/\n</code></pre> <p>Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)(v=2 votes/component, Table S22). Note: this step will delete the candidate_ pairs_G014_HH_merged.txt files.  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/\n-p candidate_pairs_G014 --sort true --parse false -c true -t 6\n</code></pre> <p>Output file for example (smaller size at station level):<code>/lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ candidate_pairs_G014_combined.txt</code> </p> <p>Finally, detect similar fingerprints across the network of 67 stations, using the input parameters in Table S23:  </p> <pre><code>~/FAST/postprocessing/$\npython scr_run_network_det.py ../parameters/postprocess/Groningen/67sta_3stathresh_network_params.json\n       \"network\": {\n              \"max_fp\": 6798013,\n              \"dt_fp\": 1.5, (seconds)\n              \"dgapL\": 10, (15 s)\n              \"dgapW\": 3, (4.5 s)\n              \"num_pass\": 2,\n              \"min_dets\": 3,\n              \"min_sum_multiplier\": 1,\n              \"max_width\": 8, (12 s)\n              \"ivals_thresh\": 6,\n              \"nsta_thresh\": 3,\n              \"input_offset\": 15 (22.5 s)\n},\n</code></pre> <p>Table S23: Network detection input parameters for Groningen at 67 stations. max_fp = 6798013 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.5 seconds is the fingerprint sampling period from Table S21.  </p> <p> </p> <p>Network detection output file for example (smaller size at station level): <code>/lfs/1/ceyoon/TimeSeries/Groningen/ network_detection/67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events)</code> </p> <p>At this point, FAST earthquake detection processing is done.  </p>"},{"location":"groningen_dataset/#085-remove-duplicates-after-network-detection","title":"0.8.5 Remove duplicates after network detection","text":"<p>The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.)  </p> <p>First, save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind).  </p> <pre><code>~/FAST/utils/network/$ python arrange_network_detection_results.py\n</code></pre> <p>Output: <code>NetworkDetectionTimes_67sta_3stathresh_detlist_rank_by_peaksum.txt</code> (118,728 events)  </p> <p>Second, remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity).  </p> <pre><code>~/FAST/utils/network/$ ./remove_duplicates_after_network.sh\n</code></pre> <p>Output: <code>uniquestart_sorted_no_duplicates.txt</code> (13,782 events)  </p> <p>Third, remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum.  </p> <pre><code>~/FAST/utils/network/$ python delete_overlap_network_detections.py\n</code></pre> <p>Output: <code>67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code> (6277 events)  </p> <p>Finally, sort remaining events in descending order of num_sta, then peaksum, for the final detection list.  </p> <pre><code>~/FAST/utils/network/$ ./final_network_sort_nsta_peaksum.sh\n</code></pre> <p>Output: <code>sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code> (6277 events)  </p>"},{"location":"groningen_dataset/#086-visual-inspection-and-final-detections","title":"0.8.6 Visual inspection and final detections","text":"<p>Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table 0.8.6).  </p> <pre><code>~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_Groningen.py 0 6277\n</code></pre> <p>Output: <code>.png</code> image files in <code>67sta_3stathresh_NetworkWaveformPlots/</code> </p> <p>Table S24: Final thresholds for Groningen applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied.  </p> <p> </p> <p>After visual inspection, 26 events are above thresholds in Table 0.8.6.  </p> <ul> <li><code>EQ_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code>: 23 events that look like earthquake waveforms  </li> <li><code>FALSE_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code>: 3 false detections above thresholds that do not look like earthquakes  </li> </ul> <p>For the 23 earthquake events, output an event catalog:  </p> <pre><code>~/FAST/utils/events/$ python output_final_detection_list.py\n</code></pre> <p>Output: <code>FINAL_Detection_List_Groningen_67sta_13stathresh.txt</code> (23 events)  </p>"},{"location":"input_and_preprocess/","title":"Input and Preprocessing","text":""},{"location":"input_and_preprocess/#input-continuous-seismic-data","title":"Input: Continuous Seismic Data","text":"<ul> <li> <p>SAC or MiniSEED formats  </p> <ul> <li>Run FAST independently for each component at each station  </li> <li> <p>Filename should have station, component, date-time  </p> <p>Warning</p> <p>Filename must end with \u201c.sac\u201d or \u201c.mseed\u201d \u2013 if not, rename it!  </p> </li> <li> <p>FAST uses ObsPy functions to read in data  </p> </li> </ul> </li> <li> <p>Time gaps ok, but must not be filled with 0\u2019s </p> <ul> <li>0\u2019s are similar to other 0\u2019s --&gt; time gaps overwhelm your earthquake detections, and take forever to run  </li> <li>Run scripts to fill 0\u2019s with random uncorrelated noise; outputs files starting with \u201cFilled*\u201d  </li> <li><code>$ python fill_time_gaps_uncorrelated_noise.py</code> calls <code>detect_time_gaps.py</code> </li> <li>Need to modify for your input data  </li> <li>Example scripts in: <code>parameters/preprocess_utils/</code> </li> </ul> </li> </ul>"},{"location":"input_and_preprocess/#preprocessing","title":"Preprocessing","text":"<p>Bandpass Filter: important parameter </p> <ul> <li> <p>FAST uses short sections of spectrogram to create fingerprints  </p> <ul> <li>Nyquist upper limit = (Sampling rate)/2  </li> <li>Typically sampling rate is 100 Hz, but depends on data  </li> </ul> </li> <li> <p>Frequencies outside passband are cut, thrown away  </p> </li> <li>Demean, detrend data before applying filter  </li> </ul> <p>Decimate to lower sampling rate</p> <ul> <li>Depends on your selected filter band; usually to 50 Hz, 25 Hz, or 20 Hz  </li> </ul> <p>Remove spikes and glitches (write your own script)  </p> <p>Example Python scripts in <code>parameters/preprocess_utils/</code> (uses ObsPy):  </p> <ul> <li><code>bandpass_filter_decimate.py</code>, <code>mseed_bandpass_filter_decimate.py</code></li> <li><code>SaudiMonth_bandpass_filter_decimate.sh</code>: calls Python script multiple times for different stations and components, different filter bands  </li> </ul>"},{"location":"italy_day_yr_dataset/","title":"0.2 ItalyDayYR Data Set","text":"<p>Info</p> <p>One day of continuous data, 2016-10-29 00:00:00 to 2016-10-29 23:59:59 UTC, at 22 stations in central Italy (Figure 2), used 22 channels (vertical component HHZ only on each channel) for detection, provided by Bill Ellsworth. This data records small earthquakes from a swarm in Central Italy during October 2016, that occurred between the Mw 6.1 earthquake on 2016-10-26 19:18:08 UTC and the Mw 6.6 Norcia earthquake on 2016-10-30 06:40:18 UTC.  </p> <p> </p> Figure 2: Map of 22 stations (black triangles) in central Italy used for FAST detection of small earthquakes on 2016-10-29, one day of continuous data. The INGV catalog (http://cnt.rm.ingv.it/search) had 482 earthquakes (circles colored by depth, sized by relative magnitudes 0.4 \u2264 M \u2264 4.1) inside the boundaries of this map on 2016-10-29."},{"location":"italy_day_yr_dataset/#021-preprocessing","title":"0.2.1 Preprocessing","text":"<p>Output sample spectrograms on each channel and station to determine bandpass filter range:  </p> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/ItalyDayYR/sample_spectrograms_ItalyDayYR.sh\n</code></pre> <p>Table S2: FAST input parameters for Italy earthquake detection: single-channel at 22 YR stations (Figure 2, black triangles), after bandpass filter 2-20 Hz, and decimate to 25 Hz. Total number of fingerprints: 71,989.  </p> <p> </p> <p>Table S3: Network detection input parameters for Italy earthquakes at 22 YR stations (HHZ channel only), after getting similar pairs of fingerprints from FAST for each station.  </p> <p> </p> <p> </p> Figure 3: Distribution of FAST detections in central Italy continuous data on 2016-10-29. FAST detected a total of 1,485 earthquakes during this day."},{"location":"network_detection/","title":"Network Detection","text":""},{"location":"network_detection/#association-detect-earthquakes-over-a-seismic-network","title":"Association: Detect Earthquakes Over a Seismic Network","text":"<p>Earthquake pair at different stations: consistent inter-event time dt Reduce false detections  </p> <p> </p>"},{"location":"network_detection/#network-multi-station-detection-with-fast","title":"Network (Multi-Station) Detection with FAST","text":""},{"location":"network_detection/#network-multi-station-illustration","title":"Network (Multi-Station) Illustration","text":""},{"location":"network_detection/#event-pair-extraction-parameters","title":"Event-Pair Extraction Parameters","text":"<pre><code>\"network\": {\n    \"dgapL\": 3,                 # Longest allowed along-diagonal time gap (samples)  \n    \u201ddgapW\": 3,                 # Longest allowed cross-diagonal time gap (samples)  \n    \u201dnum_pass\": 2,              # Adjacent diagonal merge iterations  \n    \u201divals_thresh\": 6,          # Minimum similarity (number of votes)  \n    \u201cmin_dets\": 4,              # Minimum number of fingerprint-pairs in a cluster  \n    \u201dmin_sum_multiplier\": 1,    # Minimum total similarity multiplier for a cluster  \n    \"max_width\": 8,             # Maximum bounding box width (samples)  \n}\n</code></pre> <p>Guidelines for setting parameters: </p> <ul> <li>ivals_thresh = nvote, unless initial threshold is too low. Better approach is increasing min_sum_multiplier (i.e. min_sum_multiplier = updated_nvote / nvote ) which effectively increases fingerprint-pair threshold to updated_nvote with better thresholding that takes advantage of structure of event-pairs </li> <li>min_dets = 4-6  </li> <li>dgapL: time interval equivalent to largest expected P-S gap (e.g. 10-20 seconds) </li> <li>dgapW: should be small, equivalent to a few seconds (3-4 seconds) </li> </ul> <pre><code>\"network\": {\n    \u201cmax_fp\": 74797,    # Max fingerprint index over all stations  \n    \u201ddt_fp\": 1.0,       # Fingerprint lag (s)  \n    \"dgapL\": 3,         # Longest allowed along-diagonal time gap (samples)  \n    \u201ddgapW\": 3,         # Longest allowed cross-diagonal time gap (samples)  \n    \u201dnum_pass\": 2,      # Adjacent diagonal merge iterations\n},\n</code></pre> <p> </p> Event-Pair Extraction Parameters (1 Station) <ul> <li> <p><code>dgapL</code>, <code>dgapW</code>: determine whether to keep as 1 cluster or split into 2 clusters  </p> <ul> <li>Multiply <code>dgapL</code>, <code>dgapW</code> by dt_fp to get values in seconds</li> </ul> </li> <li> <p><code>num_pass</code>=2 is good default (3 is also ok, but takes longer)  </p> </li> </ul>"},{"location":"network_detection/#event-pair-extraction-samples","title":"Event-Pair Extraction Samples","text":"<pre><code>\"network\": {\n    \u201divals_thresh\": 6,              # Minimum similarity (number of votes)  \n    \u201cmin_dets\": 4,                  # Minimum number of fingerprint-pairs in a cluster  \n    \u201dmin_sum_multiplier\": 1,        # Minimum total similarity multiplier for a cluster  \n    \"max_width\": 8,                 # Maximum bounding box width (samples)  \n},\n</code></pre> Event-Pair Pruning Parameters (1 Station) <ul> <li>Set higher thresholds on similarity in order to identify an event-pair cluster Minimum total similarity threshold: <code>ivals_thresh</code> * <code>min_dets</code> * <code>min_sum_multiplier</code> </li> <li><code>max_width</code>: 8 is a good default value, probably don\u2019t need to change  <ul> <li>multiply by dt_fp to get value in seconds  </li> </ul> </li> </ul>"},{"location":"network_detection/#network-detection-performance-parameter-guidance","title":"Network Detection Performance Parameter Guidance","text":"<pre><code>\"performance\": {\n    \"partition_size\": 2147483648,  \n    \"num_cores\": 4  \n}\n</code></pre> <ul> <li><code>partition_size</code>: Maximum size of each partition (bytes), if entire list of similarity search output pairs does not fit into memory</li> <li><code>num_cores</code>: Number of threads for parallel processing (event-pair extraction only)  </li> </ul>"},{"location":"network_detection/#pseudo-association-parameters-multiple-stations","title":"Pseudo-Association Parameters (Multiple stations)","text":"<pre><code>\u201dnetwork\": { \n    \u201dnsta_thresh\": 2,       # Minimum number of stations for detection  \n    \u201cinput_offset\": 3,      # Arrival time constraint: maximum time gap (samples)\n},\n</code></pre> <ul> <li>Set <code>nsta_thresh</code> low to begin, can increase threshold later  </li> <li>n<code>sta_thresh</code>=1: single station detection not yet thoroughly tested  </li> <li> <p>Set <code>input_offset</code> to be largest expected time gap between S wave at 1 station and P wave at another station</p> <ul> <li>Multiply by dt_fp to get value in seconds  </li> </ul> </li> <li> <p><code>input_offset</code>: arrival time constraint: maximum time gap (samples)  </p> <ul> <li><code>input_offset</code> is the longest time period that can elapse with no active detections (for a given \u2013 event-pair): after a gap of more than <code>input_offset</code> samples within a network event-pair, pseudo- association will automatically create a new network event-pair.</li> <li>A reasonable upper-bound on <code>input_offset</code> is the largest expected S-P time for any station in the network, or the largest difference in P arrival times between any pair of stations in the network, whichever is larger. Usually, <code>input_offset</code> can be shorter than this upper-bound, but the value should not be smaller than the time gap parameter used in event-pair extraction: <code>input_offset</code> &gt; <code>dgapL</code>.</li> <li>Note that because all event-pairs are only grouped together into network event-pairs only if they have nearly identical inter-event times, there is limited risk of falsely associating event-pairs or of being unable to resolve overlapping events (with detections separated by a time interval of less than <code>input_offset</code>) due to selecting the value of <code>input_offset</code> that is somewhat longer than necessary. However, <code>input_offset</code> should not be set to a value that is unnecessarily large (e.g. 60+ seconds) because this does increase the chance of spurious associations of unrelated event-pairs observed at different stations in the network.</li> <li>For most data sets, the value of network time gap parameter should lie within the range, <code>input_offset</code> = 15-40 seconds</li> </ul> </li> </ul>"},{"location":"network_detection/#event-resolution-implementation","title":"Event Resolution Implementation","text":"<ul> <li>Event resolution is applied separately to each station using detections from each station that meet network detection threshold (e.g. observed at minimum number of station)  </li> <li>In this implementation, event resolution method is relatively simple to minimize memory usage for large data sets. Specifically event resolution does not keep information about structure of pairwise detections, only whether there was a detection (in any event-pair) for each time stamp.  </li> <li>Thus in this version of the code, events that are overlapping in time at a single station with be resolved to a single event. In order to tease out two separate events that overlap in time at a single station, the user will need to go back to the network detection output from pairwise pseudo-association. Two events overlapping in time at a single station will belong to different network event-pairs (if there are two detections at the same station in the same network event-pair, then these are not overlapping events, but different phases of the same event).  </li> </ul>"},{"location":"network_detection/#event-resolution-implementation-algorithm","title":"Event Resolution Implementation Algorithm:","text":""},{"location":"network_detection/#sample-parameter-settings-2014-m82-iquique-foreshock-sequence","title":"Sample Parameter Settings: 2014 M8.2 Iquique Foreshock Sequence","text":"<p>(from Bergen &amp; Beroza, 2018)  </p> <p></p>"},{"location":"newzealand_dataset/","title":"0.10 New Zealand, Year 2010","text":"<p>Info</p> <p>The objective of this study is to detect small earthquakes in New Zealand to test earthquake triggering hypothesis. Detection results, with input parameters, are described in Rong et al. [2018]. 1 year continuous data (2010), 5 seismic stations LTZ, MQZ, KHZ, THZ, OXZ (Figure 16, black triangles), vertical components only, sampled at 100 Hz. Detections were compared against the GeoNet catalog, and visually inspected. FAST detected 11419 events: 4916 catalog events (Figure 16, red circles), 355 teleseismic events, 6123 new local earthquakes and 25 false positives (noise waveforms).  </p> <p> </p> Figure 16: New Zealand map: 5 stations (black triangles) used for FAST detection (except GVZ which was not used), and locations of GeoNet catalog events (circles). 4916 catalog events were detected by FAST (red circles). Catalog events missed by FAST are displayed as green circles."},{"location":"ometepec_dataset/","title":"0.6 Ometepec, Mexico, January - April 2012","text":"Figure 9: Map of 1 station in southern Mexico (black triangle) used for FAST detection of small earthquakes from 2012-01-01 to 2012-04-21. The SSN catalog (http://www2.ssn.unam.mx:8080/catalogo/) had 558 earthquakes (circles colored by depth, sized by relative magnitudes 2.8 \u2264 M \u2264 7.5) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.5 Ometepec earthquake on 2012-03-20. <p>Info</p> <p>The objective of this study is to identify repeating earthquake sequences as tools to measure deep aseismic slip rates [Dominguez et al., 2016], and characterize the unusually active aftershock sequence of the Mw 7.5 Omepetec, Mexico earthquake on 2012-03-20 [UNAM, 2013] (Figure 9). 112 days of continuous data (2012-01-01 to 2012-04-21) at 1 station, 3 components, provided by Luis Dominguez of Universidad Nacional Autonoma de Mexico (UNAM)-Morelia. For all 3 channels, I applied a 3-20 Hz bandpass filter, and kept the original sampling rate of 100 Hz.  </p> <p>FAST detected a total of 31,970 earthquakes during these 4 months. 30,923 were earthquakes (Figure 10), and 1,047 were noise, as determined by visual inspection. ***NOTE: postprocessing and elimination of duplicate detection pairs was done with the old MATLAB code from [Yoon et al., 2015] and [Yoon et al., 2017]. Single-station event-pair extraction with network FAST was not yet available. These were the events I sent to Luis, who performed single-station location using P-wave polarization analysis (Figure 10).  </p> <p>Table S17: FAST input parameters for Ometepec, Mexico earthquake detection, applied to each component at station IG.PNIG. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 4,795,140.  </p> <p> </p> <p> </p> Figure 10: Ometepec, Mexico earthquake detections from 2012-01-01 to 2012-04-21. The blue dots indicate the total 3-component FAST similarity (left y-axis) of the 30,923 FAST detections as a function of time. The red dots indicate the magnitudes (right y-axis) of the 558 catalog events as a function of time. Following the Mw 7.5 earthquake on 2012-03-20, aftershocks are abundant."},{"location":"params_section/","title":"How to Set Parameters","text":""},{"location":"phase_picking/","title":"Phase Picking","text":"<p>The FAST output is interfaced with SeisBench to pick the arrival time of phases automatically with machine learning models.</p> <p>SeisBench is an open-source python toolbox for machine learning in seismology. Learn more about SeisBench here.</p>"},{"location":"phase_picking/#cut-sac-files","title":"Cut SAC Files","text":"<p>In <code>cut_event_files.py</code>, change the station list on line 14 to list the stations in your dataset and the name of the final detection list on line 16.  </p> <p>Example in <code>cut_event_files</code>:  </p> <pre><code>stations = ['CDY', 'CPM', 'GTM', 'HEC', 'RMM', 'RMR', 'TPC']  # Change station list\nin_mseed_dir = '../../data/'  \nin_FINAL_Detection_List = 'network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt'  # Change final detection list\nout_dir = 'event_ids'  \n</code></pre> <p>Your continuous seismic data should be found in <code>/FAST/data/waveforms*/Deci5.Pick.*</code> </p>"},{"location":"phase_picking/#pick-phases-over-all-input","title":"Pick Phases Over All Input","text":"<p>Note</p> <p>If stations in your dataset do not have 3 channels, you will need to alter <code>run_seisbench.py</code> to make .sac file copies for stations without 3 channels.</p> <p>In the Hector Mine dataset, only the HEC station has 3 channels. On line 20 of <code>run_seisbench.py</code>, the stations that only have one component are in a list, which is iterated through to make channel copies for phase picking.  </p> <pre><code>stations = ['CDY', 'CPM', 'GTM', 'RMM', 'RMR', 'TPC'] # List of stations that do not have 3 components\n</code></pre> <p>To make sure <code>run_seisbench.py</code> runs correctly on your dataset, edit the following code in the script to account for missing station channels:  </p> <pre><code>if stream[i].stats.station in stations:\nst_temp = Stream()\ntr_temp_e = stream[i].copy()\ntr_temp_n = stream[i].copy()\ntr_temp_z = stream[i].copy()\ntr_temp_e.stats.channel = 'EHE'\nst_temp.append(tr_temp_e)\ntr_temp_n.stats.channel = 'EHN'\nst_temp.append(tr_temp_n)\ntr_temp_z.stats.channel = 'EHZ'\nst_temp.append(tr_temp_z)\nst += st_temp\nelse:\nst += stream[i] \n</code></pre> <p>Run the SeisBench script:  </p> <pre><code>~/FAST/utils/events$ cd ..\n~/FAST/utils$ cd picking\n~/FAST/utils/picking$ python run_seisbench.py\n</code></pre> <p>The plotted annotations with each station's waveform and EQTransformer's picks and detections for every event is found in:  </p> <pre><code>~/quake_tutorial/data/seisbench_picks\n</code></pre> <p>Example annotated plot from one event in the Hector Mine dataset:  </p> <p></p> <p>The phase pick information found from SeisBench is found in:  </p> <pre><code>~/quake_tutorial/utils/picking/event_picks.json/\n</code></pre> <p>Example output:  </p> <p></p> <ul> <li>\"peak_time\": Arrival time of pick</li> <li>\"peak_value\": Probability of pick</li> </ul>"},{"location":"references/","title":"References","text":"<p>(FAST Overview) C. Yoon, O. O\u2019Reilly, K. Bergen and G. C. Beroza (2015) Earthquake detection through computationally efficient similarity search, Sci. Adv. 1, e1501057.</p> <p>(Fingerprint) K. Bergen, C. Yoon and G. C. Beroza (2016) Scalable Similarity Search in Seismology: A New Approach to Large-Scale Earthquake Detection, 9th International Conference on Similarity Search and Applications, Tokyo, Japan, 1-8.</p> <p>(Network Detection) K. Bergen and G.C. Beroza (2018) Detecting Earthquakes over a Seismic Network using Single-Station Similarity Measures, Geophys. J. Int., doi:10.1093/gji/ggy100</p> <p>(Application of FAST) C. Yoon, Y. Huang, W. L. Ellsworth and G. C. Beroza (2017) Seismicity During the Initial Stages of the Guy\u2010Greenbrier, Arkansas, Earthquake Sequence, J. Geophys. Res., doi:10.1002/2017JB014946</p> <p>(Implementation and Performance) K. Rong, C. Yoon, K. Bergen, H. Elezabi, P. Bailis, P. Levis and G. C. Beroza (2018) Locality-Sensitive Hashing for Earthquake Detection: A Case Study Scaling Data-Driven Science, arXiv:1803.09835.</p>"},{"location":"saudi_dataset/","title":"0.4 Saudi Arabia, May 2014","text":"Figure 5: Map of 19 stations (white triangles) in Saudi Arabia used for FAST detection from 2014-05-01 to 2014-06-01. Catalog earthquakes are colored by depth; mantle earthquakes are circled. This figure was created by Alex Blanchette. <p>Info</p> <p>Seismic network from Saudi Arabia to study dike swarms in volcanic area, and deep mantle earthquakes. 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations (Figure 5), 55 channels (3 components per station, except LNY11 where only HHN was used), provided by Alex Blanchette of Stanford Geophysics.  </p> <p>Table S7: Preprocessing parameters for Saudi Arabia May 2014 earthquake detection, for each station (same filter applied to all components), 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations, decimate to 25 Hz. Also, all time gaps with 0\u2019s were filled with uncorrelated random noise. For station LNY11, only HHN component was used in similarity search, as the HHE and HHZ components had too much correlated noise.  </p> <p> </p> <p>Table S8: FAST input parameters for Saudi Arabia May 2014 earthquake detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989.  </p> <p> </p> <p>Table S9: Network detection input parameters for Saudi Arabia May 2014 earthquake detection at 19 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6.  </p> <p> </p> <p>Table S10: Final thresholds for Saudi Arabia May 2014 earthquake detection, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.  </p> <p> </p> <p> </p> Figure 6: Saudi Arabia earthquake detections from 2014-05-01 to 2014-06-01. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S10). FAST detected a total of 1,837 earthquakes during this month."},{"location":"saudifull_dataset/","title":"0.5 SaudiFull Data Set: Saudi Arabia, January - May 2017","text":"<ul> <li>Location: Saudi Arabia, January - May 2017 (volcanic area with dikes)  </li> <li>Duration: up to 5 months (151 days): 2017-01-01 to 2017-05-30  </li> <li>Network: 36 stations, 3 components each (HHE, HHN, HHZ) = 106 channels. (Station SA.UMJ02: only HHE channel)  </li> <li>Sampling rate: 100 Hz  </li> <li>Provided by: Mohammad Youssof (KAUST)  </li> </ul>"},{"location":"saudifull_dataset/#051-preprocessing","title":"0.5.1 Preprocessing","text":"<ul> <li>Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/continuous_data_times_SaudiFull.sh\n</code></pre> <p>The output files in <code>continuous_duration/</code> can be read into a custom script called <code>plot_continuous_ duration_SaudiFull.py</code> to plot the duration of available continuous data at each station and channel (Figure 7).  </p> <p> </p> Figure 7: Duration of SaudiFull continuous data at 36 stations (change colors with each station), 3 components each (except SA.UMJ02 which has only HHE). White sections indicate time gaps. <ul> <li>Detected zero-filled time-gap sections of continuous data in all 106 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py), and filled them with random uncorrelated noise:  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py  \n</code></pre> <p>Only stations SA.UMJ03, SA.UMJ05, SA.UMJ08 had zero-filled time-gap sections, which were filled with random noise and saved as files starting with the <code>Filled.*</code> string. The majority of continuous data files had no zero-filled time gaps, so we used original mseed data files.  </p> <ul> <li>Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/sample_spectrograms_SaudiFull.sh\n</code></pre> <ul> <li>Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py):  </li> </ul> <pre><code>~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/bandpass_filter_decimate_SaudiFull.sh\n</code></pre> <p>Based on sample spectrograms, apply a station-specific bandpass filter (Table S11). Decimate by a factor of 2 to a sampling rate of 50 Hz. Filtered continuous data files start with <code>Deci2.bpXtoY.*</code>, where X is the lower frequency and Y is the higher frequency, which are input to the fingerprint step.  </p> <p>Table S11: Preprocessing parameters for SaudiFull earthquake detection, for each station (same filter applied to all components), 5 months continuous data (2017-01-01 to 2017-05-31), at 36 stations, decimate to 50 Hz.  </p> <p> </p>"},{"location":"saudifull_dataset/#052-fingerprint","title":"0.5.2 Fingerprint","text":"<p>Master script to create fingerprints on each channel, then generate global indices at the end:  </p> <pre><code>~/FAST/fingerprint/$ ../parameters/fingerprint/SaudiFull/run_fp_SaudiFull.sh\n</code></pre> <p>Example script to generate fingerprints on one channel (HHZ) at one station (LNY03), called by the master script run_fp_SaudiFull.sh:  </p> <pre><code>~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/SaudiFull/fp_input_SA_LNY03_HHZ.json\n    \"fingerprint\": {\n       \"sampling_rate\": 50,\n       \"min_freq\": 4.0,\n       \"max_freq\": 15.0,\n       \"spec_length\": 6.0,\n       \"spec_lag\": 0.12,\n       \"fp_length\": 64,\n       \"fp_lag\": 10,\n       \"k_coef\": 400,\n       \"nfreq\": 32,\n       \"mad_sampling_rate\": 0.1,\n       \"mad_sample_interval\": 86400\n    \"data\": {\n       \"station\": \"LNY03\",\n       \"channel\": \"HHZ\",\n       \"start_time\": \"17-01-01T00:00:00.0\",\n       \"end_time\": \"17-05-31T00:00:00.0\",\n       \"folder\": \"/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/\",\n</code></pre> <p>There are a total of 106 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S12.  </p> <p>Median/MAD output files: <code>mad/mad*.txt</code> </p> <p>Table S12: Fingerprint input parameters for SaudiFull earthquake detection: 3-component at 36 stations (except for SA.UMJ02), after applying station-specific bandpass filter (Table S11), and sampled at 50 Hz. The fingerprint sampling period is dt_fp = 1.2 seconds.  </p> <p> </p> <p>Fingerprints (binary files): <code>fingerprints/LNY03.HHZ.fp</code> Timestamps at each fingerprint index (text files): <code>timestamps/LNY03.HHZ.ts</code> </p> <p>Finally, to create global indices for the SaudiFull data set, so that fingerprint indices from different channels (all 106) and stations are referenced to a common starting time:  </p> <pre><code>$ python global_index.py ../parameters/fingerprint/SaudiFull/global_indices_SaudiFull.json  \n</code></pre> <p>The common starting time is in <code>global_idx_stats.txt</code>: 2017-01-01T00:00:06.840000 UTC  </p>"},{"location":"saudifull_dataset/#053-similarity-search","title":"0.5.3 Similarity Search","text":"<p>Master script to run similarity search on each channel (out of 106 total):  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/run_simsearch_SaudiFull.sh  \n</code></pre> <p>Table S13: Similarity search input parameters for SaudiFull earthquake detection: 106 channels at 36 stations (3 components each, except SA.UMJ02). The occurrence filter, specified by the FREQ_NOISE parameter, was applied only for selected stations and channels (Table S14).  </p> <p> </p> <p>Example script to run similarity search on one channel (HHZ) at one station (LNY03), called by the master script <code>run_simsearch_SaudiFull.sh</code>:  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/simsearch_input_SaudiFull.sh LNY03 HHZ\nNTBLS=100\nNHASH=4\nNREPEAT=5\nNVOTES=2\nNTHREAD=56\nNUM_PART=1\n</code></pre> <p>We first ran similarity search with the same input parameters on all 106 channels, without the occurrence filter. For 18 selected channels (Table S14), where the <code>candidate_pairs</code> similarity search outputs were especially large because of correlated noise, we ran similarity search with the occurrence filter (FREQ_NOISE=0.01), which significantly reduced the similarity search output file sizes. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. For example, the occurrence filter was applied for station LNY01 channel HHZ by calling the script <code>filt_simsearch_input_SaudiFull.sh</code> from the master script <code>run_simsearch_SaudiFull.sh</code>:  </p> <pre><code>~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/filt_simsearch_input_SaudiFull.sh LNY03 HHZ\nNTBLS=100\nNHASH=4\nNREPEAT=5\nNVOTES=2\nNTHREAD=56\nNUM_PART=1\nFREQ_NOISE=0.01\n</code></pre> <p>Table S14: Selected stations and channels from SaudiFull data set where we applied the occurrence filter with FREQ_ NOISE=0.01.  </p> <p> </p>"},{"location":"saudifull_dataset/#054-postprocessing","title":"0.5.4 Postprocessing","text":"<p>First, run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (106 total):  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/output_SaudiFull_pairs.sh\n</code></pre> <p>For example, on one channel (HHZ) at one station (LNY03), all on one line:  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/\n-p candidate_pairs_LNY03_HHZ -i /lfs/1/ceyoon/TimeSeries/SaudiFull/global_indices/LNY03_HHZ_idx_mapping.txt\n</code></pre> <p>Output file for example (large size at channel level): <code>/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/candidate_pairs_LNY03_HHZ_merged.txt</code> </p> <p>Second, run the master script to combine similarity output from all 3 components at a given station, for all 36 stations:  </p> <pre><code>~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/combine_SaudiFull_pairs.sh  \n</code></pre> <p>Example</p> <p>For example, on three channels (HHE, HHN, HHZ) at one station (LNY03), first move the similarity output text files to the inputs_network/ directory:  </p> <pre><code>$ cd /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/\n$ mv candidate_pairs_LNY03_HH*_merged.txt ../../../inputs_network/\n</code></pre> <p>Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S13). Note: this step will delete the c<code>andidate_ pairs_LNY03_HH*_merged.txt</code> files.  </p> <pre><code>~/FAST/postprocessing/$ python parse_results.py\n-d /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/\n-p candidate_pairs_LNY03 --sort true --parse false -c true -t 6\n</code></pre> <p>Output file for example (smaller size at station level): <code>/lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ candidate_pairs_LNY03_combined.txt</code> </p> <p>For station SA.UMJ02, which has only 1 component (HHE), multiply the similarity sim by 3 to give this station an equal weight as the other 3-component stations:  </p> <pre><code>~/FAST/postprocessing/$ awk \u2019{print $1, $2, 3*$3}\u2019\n/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_HHE_merged.txt\n&gt; /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_combined.txt\n</code></pre> <p>Finally, detect similar fingerprints across the network of 36 stations, using the input parameters in Table S15:  </p> <pre><code>~/FAST/postprocessing/$\npython scr_run_network_det.py ../parameters/postprocess/SaudiFull/36sta_3stathresh_network_params.json\n       \"network\": {\n              \"max_fp\": 10736786,\n              \"dt_fp\": 1.2, (seconds)\n              \"dgapL\": 10, (12 s)\n              \"dgapW\": 3, (3.6 s)\n              \"num_pass\": 2,\n              \"min_dets\": 3,\n              \"min_sum_multiplier\": 1,\n              \"max_width\": 8, (9.6 s)\n              \"ivals_thresh\": 6,\n              \"nsta_thresh\": 3,\n              \"input_offset\": 15 (18 s)\n},\n</code></pre> <p>Network detection output file for example (smaller size at station level): <code>/lfs/1/ceyoon/TimeSeries/SaudiFull/ network_detection/36sta_3stathresh_detlist_rank_by_peaksum.txt</code> (21,498 events)  </p> <p>At this point, FAST earthquake detection processing is done.  </p> <p>Table S15: Network detection input parameters for SaudiFull at 36 stations. max_fp = 10736786 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.2 seconds is the fingerprint sampling period from Table S12.  </p> <p> </p>"},{"location":"saudifull_dataset/#055-remove-duplicates-after-network-detection","title":"0.5.5 Remove Duplicates After Network Detection","text":"<p>Info</p> <p>The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.)  </p> <p>First, save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind).  </p> <pre><code>~/FAST/utils/network/$ python arrange_network_detection_results.py\n</code></pre> <p>Output: <code>NetworkDetectionTimes_36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events)</code> </p> <p>Second, remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity).  </p> <pre><code>~/FAST/utils/network/$ ./remove_duplicates_after_network.sh  \n</code></pre> <p>Output: <code>uniquestart_sorted_no_duplicates.txt (15,054 events)</code> </p> <p>Third, remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum.  </p> <pre><code>~/FAST/utils/network/$ python delete_overlap_network_detections.py  \n</code></pre> <p>Output: <code>36sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt</code> (11,597 events)  </p> <p>Fourth, since different channels in the network have different durations (for example, in Figure 7, stations UMJ01-UMJ12 were active only during May 2017, while many of the other stations were active from January to May 2017), we calculate a normalized measure of the number of stations that detected the event: frac_ch, which is the fraction of channels that were active at each detection time. This is done by reading in files that were generated during preprocessing by get_continuous_data_times.py. This normalization step would not be necessary if all stations and channels in the network recorded the same duration of data.  </p> <pre><code>~/FAST/utils/network/$ python get_station_count_detections.py\n</code></pre> <p>Output: <code>36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt</code> (11,597 events)  </p> <p>Finally, sort remaining events in descending order of num_sta, then frac_ch, then peaksum, for the final detection list.  </p> <pre><code>~/FAST/utils/network/$ ./final_network_sort_nsta_fracch_peaksum.sh\n</code></pre> <p>Output: <code>sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt</code> (11,597 events)  </p>"},{"location":"saudifull_dataset/#056-visual-inspection-and-final-detections","title":"0.5.6 Visual Inspection and Final Detections","text":"<p>Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table S16).  </p> <pre><code>~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_SaudiFull.py 0 11597\n</code></pre> <p>Output: <code>.png</code> image files in <code>36sta_3stathresh_NetworkWaveformPlots/</code> </p> <p>Table S16: Final thresholds for SaudiFull applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied.  </p> <p> </p> <p>After visual inspection, 4634 events are above thresholds in Table S16.  </p> <ul> <li><code>EQ_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt</code>: 4543 events that look like earthquake waveforms  </li> <li><code>FALSE_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt</code>: 91 false detections above thresholds that do not look like earthquakes  </li> </ul> <p>For the 4543 earthquake events, output an event catalog (Figure 8):  </p> <pre><code>~/FAST/utils/events/$ python output_final_detection_list.py\n</code></pre> <p>Output: <code>FINAL_Detection_List_SaudiFull_36sta_3stathresh.txt</code> (4543 events)  </p> <p> </p> Figure 8: Saudi Arabia earthquake detections from 2017-01-01 to 2017-05-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S16). FAST detected a total of 4,543 earthquakes during this month."},{"location":"setup_colab/","title":"Installation for Google Colab","text":"<p>Info</p> <p>If you are new to FAST, testing out FAST in Google Colab is a great way to get an overview of the software and learn how to test your own data.  </p>"},{"location":"setup_colab/#what-is-colab","title":"What is Colab?","text":"<p>Colab is a free Jupyter notebook environment that runs entirely in the cloud. It lets you and your team members edit documents the way you work with Google Docs and also run code on a data set and visualize the results. Colab supports many popular machine learning libraries which can be easily loaded in your notebook.</p> <p></p> The relationship between iPython, Jupyter Notebook, and Google Colab. (Source)"},{"location":"setup_colab/#run-fast-in-colab","title":"Run FAST in Colab","text":"<p>To run FAST in Google Colab, copy this Google Colab FAST example using data from the Hector Mine into your Google drive.</p> <p>The Colab uses a small example data set from the Hector Mine with 7 stations and less than one day long. With the Hector Mine data set, you can run the end-to-end FAST pipeline, from fingerprint to output list of detection times, in just a few minutes, since it is a small data set.</p> <p>If you want to learn how to use FAST as a beginner, using the Hector Mine example data set is suggested since a bigger data set might take hours, which is not useful.</p> <p>Use the instructions in the How to Set Parameters section to prepare and test your own data set.</p>"},{"location":"setup_docker/","title":"Installation for Docker","text":"<p>Docker is an open-source project for automating the deployment of applications as portable, self-sufficient containers that can run on the cloud or on-premises. (Source)</p> <p>Docker lets you run FAST on a non-Linux operating system, so it is recommended for Mac or Windows users.</p>"},{"location":"setup_docker/#install-docker","title":"Install Docker","text":"<p>Install Docker on your machine here. To get started, make sure Docker has been successfully installed by running:</p> <pre><code>$ docker run hello-world\n</code></pre> <p>You should see the <code>Hello from Docker!</code> message displayed. Otherwise, refer to Docker's documentation for getting started here.</p> <p>Warning</p> <p>By default, Docker for Mac allocates 2.00GB of RAM. The more memory available on Docker, the faster FAST will run. Please refer to Docker's Docker Desktop for Mac user manual for more information on how to increase the allocated memory.</p>"},{"location":"setup_docker/#setting-up-docker-for-fast","title":"Setting up Docker for FAST","text":"<p>Create a directory for FAST code and outputs</p> <pre><code>$ mkdir DockerFAST\n</code></pre> <p>Change permissions so that Docker can write to this directory</p> <pre><code>$ chmod 777 DockerFAST\n</code></pre> <p>Clone the FAST repository from GitHub into a local directory named <code>./FAST/</code></p> <pre><code>$ cd DockerFAST\n$ git clone https://github.com/stanford-futuredata/FAST.git ./FAST/\n</code></pre> <p>Build the Docker image</p> <p>Note</p> <p>Building the Docker image with Dockerfile with set up all FAST dependencies (Linux Ubuntu 18.04, CMake compiler, C++ boost, conda for python virtual environment and libraries).</p> <pre><code>$ cd FAST/\n$ docker build -f Dockerfile -t fast_image:0.1 .\n</code></pre> <ul> <li><code>-f</code> - Name of the Dockerfile</li> <li><code>-t</code> - Tag name</li> </ul> <p>Run the Docker image in a Docker container</p> <pre><code>$ docker run -v ${PWD}:/app -it fast_image:0.1 /bin/bash\n</code></pre> <ul> <li><code>-v</code> - Bind mount a volume. The current directory in ${PWD} is mounted inside the container into the directory /app, so that any changes to files made inside the container are saved to disk and persist after exiting the container.</li> <li><code>-it</code> - Short for --interactive + --tty, which takes you inside the container in interactive mode, allowing you to run commands on the command line in the container, which we need to run FAST.</li> </ul> <p>Now we are in the Docker container, in the <code>eq_fast</code> conda environment. We are ready to run FAST now. <pre><code>(eq_fast) root@555d364b63d7:/app/FAST#\n</code></pre></p>"},{"location":"setup_docker/#running-fast-with-docker","title":"Running FAST with Docker","text":"<p>Refer to the Tutorial for more detailed information about FAST parameters, inputs, and outputs.</p>"},{"location":"setup_docker/#generate-fingerprints-for-the-data-set","title":"Generate fingerprints for the data set","text":"<pre><code>(eq_fast) root@555d364b63d7:/app/FAST# python run_fp.py -c config.json\n</code></pre>"},{"location":"setup_docker/#search-for-similar-earthquakes","title":"Search for Similar Earthquakes","text":"<pre><code>(eq_fast) root@555d364b63d7:/app/FAST# cd simsearch/\n(eq_fast) root@555d364b63d7:/app/FAST/simsearch# cmake .\n(eq_fast) root@555d364b63d7:/app/FAST/simsearch# make\n(eq_fast) root@555d364b63d7:/app/FAST/simsearch# cd ..\n(eq_fast) root@555d364b63d7:/app/FAST# python run_simsearch.py -c config.json\n</code></pre>"},{"location":"setup_docker/#postprocess-parse-fast-similarity-search-output","title":"Postprocess: Parse FAST Similarity Search Output","text":"<pre><code>(eq_fast) root@555d364b63d7:/app/FAST# cd postprocessing/\n(eq_fast) root@555d364b63d7:/app/FAST/postprocessing# ../parameters/postprocess/output_HectorMine_pairs.sh\n(eq_fast) root@555d364b63d7:/app/FAST/postprocessing# ../parameters/postprocess/combine_HectorMine_pairs.sh\n</code></pre>"},{"location":"setup_docker/#postprocess-network-detection","title":"Postprocess: Network Detection","text":"<pre><code>(eq_fast) root@555d364b63d7:/app/FAST/postprocessing# python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json\n</code></pre>"},{"location":"setup_docker/#postprocess-clean-network-detection-results","title":"Postprocess: Clean Network Detection Results","text":"<p>Need to modify inputs within each script file to your data set. <pre><code>(eq_fast) root@555d364b63d7:/app/FAST/postprocessing# cd ../utils/network/\n(eq_fast) root@555d364b63d7:/app/FAST/utils/network# python arrange_network_detection_results.py\n(eq_fast) root@555d364b63d7:/app/FAST/utils/network# ./remove_duplicates_after_network.sh\n(eq_fast) root@555d364b63d7:/app/FAST/utils/network# python delete_overlap_network_detections.py\n(eq_fast) root@555d364b63d7:/app/FAST/utils/network# ./final_network_sort_nsta_peaksum.sh\n</code></pre></p>"},{"location":"setup_docker/#visualize-the-fast-output","title":"Visualize the FAST Output","text":"<pre><code>(eq_fast) root@555d364b63d7:/app/FAST/utils/network# cat ../../data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre>"},{"location":"setup_docker/#display-waveforms-for-fast-detections-in-descending-order-of-peaksum-similarity","title":"Display Waveforms for FAST Detections in Descending Order of \"peaksum\" Similarity","text":"<p>This example outputs png images for 100 event waveforms. The plot file names are sorted in descending order by: <code>num_sta</code> (number of stations that detected this event), <code>peaksum</code> (peak total similarity)</p> <pre><code>(eq_fast) root@555d364b63d7:/app/FAST/utils/network# cd ..\n(eq_fast) root@555d364b63d7:/app/FAST/utils# cd events/\n(eq_fast) root@555d364b63d7:/app/FAST/utils/events# python PARTIALplot_detected_waveforms_HectorMine.py 0 100\n</code></pre> <p>Note</p> <p>View images outside Docker container \u2014 to manually determine detection threshold <pre><code>$ ls ../../data/network_detection/7sta_2stathresh_NetworkWaveformPlots/\nevent_rank00000_nsta7_peaksum1015_ind6204_time6204.0_1999-10-15T14:43:24.676000.png\nevent_rank00001_nsta7_peaksum1015_ind3842_time3842.0_1999-10-15T14:04:02.676000.png\nevent_rank00002_nsta7_peaksum920_ind7488_time7488.0_1999-10-15T15:04:48.676000.png\nevent_rank00003_nsta7_peaksum823_ind5286_time5286.0_1999-10-15T14:28:06.676000.png\nevent_rank00004_nsta7_peaksum718_ind20202_time20202.0_1999-10-15T18:36:42.676000.png\nevent_rank00005_nsta7_peaksum713_ind46536_time46536.0_1999-10-16T01:55:36.676000.png\n...\n</code></pre></p>"},{"location":"setup_docker/#set-detection-threshold","title":"Set Detection Threshold","text":"<p>Note</p> <p>Everything above the detection threshold is deemed an earthquake. In this example, the first 50 events with the highest \"peaksum\" similarity are identified as earthquakes, while the remaining events are not earthquakes.</p> <pre><code>(eq_fast) root@555d364b63d7:/app/FAST/utils/events# cd ../../data/network_detection/\n(eq_fast) root@555d364b63d7:/app/FAST/data/network_detection# head -50 sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt &gt; EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre>"},{"location":"setup_docker/#output-final-fast-detected-event-list","title":"Output Final FAST Detected Event List","text":"<pre><code>(eq_fast) root@555d364b63d7:/app/FAST/data/network_detection# cd ../../utils/events/\n(eq_fast) root@555d364b63d7:/app/FAST/utils/events# python output_final_detection_list.py\n(eq_fast) root@555d364b63d7:/app/FAST/utils/events# cat ../../data/network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt\n</code></pre>"},{"location":"setup_docker/#phase-picking-earthquake-location-map-visualization","title":"Phase Picking, Earthquake Location, Map Visualization","text":"<p>Refer to the Tutorial for more information and detailed commands for optional next steps to take after running FAST:</p> <ul> <li>Phase Picking with SeisBench</li> <li>Earthquake Location with HYPOINVERSE</li> <li>Mapping and Visualization with PyGMT</li> </ul>"},{"location":"setup_docker/#exiting-the-docker-container","title":"Exiting the Docker Container","text":"<pre><code>(pygmt) root@555d364b63d7:/app/FAST/utils/mapping# exit\nexit\n</code></pre> <p>After exiting the Docker container, all files created within the container should still be accessible on your disk since the current directory was mounted inside the container with <code>docker run -v ${PWD}:/app</code>.</p>"},{"location":"setup_docker/#view-status-of-the-docker-container","title":"View status of the Docker Container","text":"<pre><code>$ docker ps -a\nCONTAINER ID   IMAGE                             COMMAND                  CREATED        STATUS                      PORTS     NAMES\n555d364b63d7   fast_image:0.1                    \"/bin/bash\"              6 days ago     Exited (1) 25 seconds ago             pensive_ramanujan\n</code></pre>"},{"location":"setup_docker/#enter-docker-container-again","title":"Enter Docker Container again","text":"<p>We can pick up where we left off after entering the same Docker container again. Notice that the <code>pygmt</code> conda environment is still there. <pre><code>$ docker start -i 555d364b63d7\n(eq_fast) root@555d364b63d7:/# cd app\n(eq_fast) root@555d364b63d7:/app# ls\nCalipatria      FAST_userguide_v0.pdf  __pycache__                      changes                 data             fingerprint  parse_config.py   run_fp.py         utils\nCalipatria.zip  LICENSE                calipatria_client.ipynb          config.json             docs             mkdocs.yml   postprocessing    run_simsearch.py\nDockerfile      README.md              calipatria_massdownloader.ipynb  config_calipatria.json  environment.yml  parameters   requirements.txt  simsearch\n(eq_fast) root@6006660926e5:/app# conda env list\n# conda environments:\n#\nbase                     /root/miniconda3\neq_fast               *  /root/miniconda3/envs/eq_fast\npygmt                    /root/miniconda3/envs/pygmt\n</code></pre></p>"},{"location":"setup_docker/#remove-all-docker-containers-and-images","title":"Remove all Docker Containers and Images","text":"<p>Warning</p> <p>ONLY DO THIS WHEN YOU WANT TO REMOVE ALL DOCKER CONTAINERS AND IMAGES!!!</p> <p>This step will free up lots of space on your computer.</p> <pre><code>$ docker system prune\nWARNING! This will remove:\n- all stopped containers\n- all networks not used by at least one container\n- all dangling images\n- all dangling build cache\n</code></pre>"},{"location":"setup_linux/","title":"Installation for Linux","text":""},{"location":"setup_linux/#requirements","title":"Requirements","text":"<p>FAST is written in Python and C++ and is designed to run on Linux clusters.  </p> <p>Install instructions might not work for Windows and macOS machines. Refer to the installation instructions for Google Colab or Docker if you want to run FAST on a machine other than Linux.  </p> <p>The code will benefit from running on machines with more memory and CPUs.  </p> <ul> <li>Consider using instances from Amazon AWS or Google Cloud  </li> </ul>"},{"location":"setup_linux/#install-fast","title":"Install FAST","text":"<p>Clone the FAST repository from GitHub into a local directory named <code>./FAST/</code> <pre><code>(base) ~$ git clone https://github.com/stanford-futuredata/FAST.git ./FAST/\n</code></pre></p> <p>Install utilities (if not already installed) <pre><code>(base) ~$ sudo apt-get install -y wget\n(base) ~$ sudo apt-get install -y jq\n</code></pre></p> <p>Install C++ dependencies <pre><code>(base) ~$ sudo apt-get install -y cmake\n(base) ~$ sudo apt-get install -y build-essential\n(base) ~$ sudo apt-get install -y libboost-all-dev\n</code></pre></p> <p>Install Python dependencies in the <code>eq_fast</code> conda environment This requires having Anaconda or Miniconda already installed on your computer <pre><code>(base) ~$ cd FAST/\n(base) ~/FAST$ conda env create -f environment.yml -n eq_fast\n</code></pre></p> <p>Activate <code>eq_fast</code> conda environment before running FAST <pre><code>(base) ~/FAST$ conda activate eq_fast\n(eq_fast) ~/FAST$\n</code></pre></p>"},{"location":"setup_linux/#run-fast","title":"Run FAST","text":"<p>Refer to the Tutorial for more detailed information about FAST parameters, inputs, and outputs.</p>"},{"location":"setup_linux/#dataset","title":"Dataset","text":"<p>Raw SAC files for each station are stored under <code>data/waveforms${STATION}</code>. Station \"HEC\" has 3 components so it should have 3 time series data files; the other stations have only 1 component.  </p>"},{"location":"setup_linux/#fingerprint","title":"Fingerprint","text":"<p>Parameters for each station are under <code>parameters/fingerprint/</code>. To fingerprint all stations and generate the global index, you can call the wrapper script (Python):  </p> <pre><code>(eq_fast) ~/FAST$ python run_fp.py -c config.json\n</code></pre> <p>An alternate option for the fingerprint wrapper script (bash):</p> <pre><code>(eq_fast) ~/FAST$ cd fingerprint/\n(eq_fast) ~/FAST/fingerprint$ ../parameters/fingerprint/run_fp_HectorMine.sh\n</code></pre> <p>The fingerprinting step takes less than 1 minute per waveform file on a 2.60GHz CPU.</p> <p>The generated fingerprints can be found at <code>data/waveforms${STATION}/fingerprints/${STATION}${CHANNEL}.fp</code>.</p> <p>The json file <code>data/waveforms${STATION}/${STATION}_${CHANNEL}.json</code> contains information about the fingerprint file, including number of fingerprints (<code>nfp</code>) and dimension of each fingerprint (<code>ndim</code>).</p> <p>To fingerprint a specific channel/station, call the fingerprint script with the corresponding fingerprint parameter file (this is one line from <code>run_fp_HectorMine.sh</code>):</p> <pre><code>(eq_fast) ~/FAST$ cd fingerprint/\n(eq_fast) ~/FAST/fingerprint$ python gen_fp.py ../parameters/fingerprint/fp_input_CI_CDY_EHZ.json\n</code></pre> <p>In addition to generating fingerprints, the wrapper script calls the global index generation script automatically. The global index (as opposed to index with a single component) is a consistent way to refer to fingerprint times at different components and stations. Global index generation should only be performed after you've generated fingerprints for every component and station that is used in the detection:  </p> <pre><code>(eq_fast) ~/FAST/fingerprint$ python global_index.py  ../parameters/fingerprint/global_indices.json\n</code></pre> <p>The resulting global index mapping for each component is stored at <code>data/global_indices/${STATION}_${CHANNEL}_idx_mapping.txt</code>, where line i in the file represents the global index for fingerprint i-1 in this component.  </p>"},{"location":"setup_linux/#similarity-search","title":"Similarity Search","text":"<p>Compile and build the code for similarity search:  </p> <pre><code>(eq_fast) ~/FAST$ cd simsearch\n(eq_fast) ~/FAST/simsearch$ cmake .\n(eq_fast) ~/FAST/simsearch$ make\n</code></pre> <p>Call the wrapper script to run similarity search for all stations:  </p> <pre><code>(eq_fast) ~/FAST/simsearch$ cd ..\n(eq_fast) ~/FAST$ python run_simsearch.py -c config.json\n</code></pre> <p>An alternate option for the similarity search wrapper script (bash):</p> <pre><code>(eq_fast) ~/FAST$ cd simsearch/\n(eq_fast) ~/FAST/simsearch$ ../parameters/simsearch/run_simsearch_HectorMine.sh\n</code></pre> <p>To run the similarity search for each channel/station individually:</p> <pre><code>(eq_fast) ~/FAST$ cd simsearch/\n(eq_fast) ~/FAST/simsearch$ ../parameters/simsearch/simsearch_input_HectorMine.sh CDY EHZ\n</code></pre>"},{"location":"setup_linux/#postprocess-parse-fast-similarity-search-output","title":"Postprocess: Parse FAST Similarity Search Output","text":"<p>The following scripts parse the binary output from similarity search to text files, and combine the three channel results for station HEC to a single output. Finally, it copies the parsed outputs to directory <code>../data/inputs_network/</code>.</p> <pre><code>(eq_fast) ~/FAST$ cd postprocessing/\n(eq_fast) ~/FAST/postprocessing$ ../parameters/postprocess/output_HectorMine_pairs.sh\n(eq_fast) ~/FAST/postprocessing$ ../parameters/postprocess/combine_HectorMine_pairs.sh\n</code></pre>"},{"location":"setup_linux/#postprocess-network-detection","title":"Postprocess: Network detection","text":"<pre><code>(eq_fast) ~/FAST/postprocessing$ python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json\n</code></pre> <p>Results from the network detection are under <code>data/network_detection/7sta_2stathresh_detlist*</code>. The file contains a list of potential detections including information about starting fingerprint index (global index, or time) at each station, number of stations where we found other events similar to this event (<code>nsta</code>), total number of similar fingerprint pairs mapped to the event (<code>tot_ndets</code>), total sum of the similarity values (<code>tot_vol</code>). Detailed format of the output can be found in the user guide.</p>"},{"location":"setup_linux/#postprocess-clean-network-detection-results","title":"Postprocess: Clean Network Detection Results","text":"<p>Need to modify inputs within each script file to your data set.</p> <pre><code>(eq_fast) ~/FAST$ cd utils/network/\n(eq_fast) ~/FAST/utils/network$ python arrange_network_detection_results.py\n(eq_fast) ~/FAST/utils/network$ ./remove_duplicates_after_network.sh\n(eq_fast) ~/FAST/utils/network$ python delete_overlap_network_detections.py\n(eq_fast) ~/FAST/utils/network$ ./final_network_sort_nsta_peaksum.sh\n</code></pre> <p>The results from the above scripts can be found at <code>data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt</code></p> <p>The above section only works with detection results with multiple stations. For single station detections, you can parse the results in the output file. The schema of the output file is: event_start (starting fingerprint index), event_dt, ndets (total number of event-pairs that include this event), peaksum (peak total similarity), and volume (sum of all similarity values for all event-pairs containing this event). Large peaksums usually correspond to higher confidence.  </p>"},{"location":"setup_linux/#visualize-the-fast-output","title":"Visualize the FAST Output","text":"<pre><code>(eq_fast) ~/FAST/utils/network$ cat ../../data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre>"},{"location":"setup_linux/#display-waveforms-for-fast-detections-in-descending-order-of-peaksum-similarity","title":"Display Waveforms for FAST Detections in Descending Order of \"peaksum\" Similarity","text":"<p>This example outputs png images for 100 event waveforms. The plot file names are sorted in descending order by: <code>num_sta</code> (number of stations that detected this event), <code>peaksum</code> (peak total similarity)</p> <pre><code>(eq_fast) ~/FAST/utils/network$ cd ..\n(eq_fast) ~/FAST/utils$ cd events/\n(eq_fast) ~/FAST/utils/events$ python PARTIALplot_detected_waveforms_HectorMine.py 0 100\n</code></pre> <p>Note</p> <p>View waveform images \u2014 to manually determine detection threshold <pre><code>$ ls ../../data/network_detection/7sta_2stathresh_NetworkWaveformPlots/\nevent_rank00000_nsta7_peaksum1015_ind6204_time6204.0_1999-10-15T14:43:24.676000.png\nevent_rank00001_nsta7_peaksum1015_ind3842_time3842.0_1999-10-15T14:04:02.676000.png\nevent_rank00002_nsta7_peaksum920_ind7488_time7488.0_1999-10-15T15:04:48.676000.png\nevent_rank00003_nsta7_peaksum823_ind5286_time5286.0_1999-10-15T14:28:06.676000.png\nevent_rank00004_nsta7_peaksum718_ind20202_time20202.0_1999-10-15T18:36:42.676000.png\nevent_rank00005_nsta7_peaksum713_ind46536_time46536.0_1999-10-16T01:55:36.676000.png\n...\n</code></pre></p> <p>Similarly, to plot results for single station detection, we need a global start time (t0) from global_idx_stats.txt, dt_fp in seconds:  </p> <ul> <li>Event time = t0 + dt_fp * (start fingerprint index)</li> </ul>"},{"location":"setup_linux/#set-detection-threshold","title":"Set Detection Threshold","text":"<p>Note</p> <p>Everything above the detection threshold is deemed an earthquake. In this example, the first 50 events with the highest \"peaksum\" similarity are identified as earthquakes, while the remaining events are not earthquakes.</p> <pre><code>(eq_fast) ~/FAST/utils/events$ cd ../../data/network_detection/\n(eq_fast) ~/FAST/data/network_detection$ head -50 sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt &gt; EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre>"},{"location":"setup_linux/#output-final-fast-detected-event-list","title":"Output Final FAST Detected Event List","text":"<pre><code>(eq_fast) ~/FAST/data/network_detection$ cd ../../utils/events/\n(eq_fast) ~/FAST/utils/events$ python output_final_detection_list.py\n(eq_fast) ~/FAST/utils/events$ cat ../../data/network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt\n</code></pre>"},{"location":"setup_linux/#phase-picking-earthquake-location-map-visualization","title":"Phase Picking, Earthquake Location, Map Visualization","text":"<p>Refer to the Tutorial for more information and detailed commands for optional next steps to take after running FAST:</p> <ul> <li>Phase Picking with SeisBench</li> <li>Earthquake Location with HYPOINVERSE</li> <li>Mapping and Visualization with PyGMT</li> </ul>"},{"location":"sim_search/","title":"Similarity Search","text":""},{"location":"sim_search/#hashing","title":"Hashing","text":""},{"location":"sim_search/#min-hash","title":"Min-Hash*","text":""},{"location":"sim_search/#example-min-hash-signature-mhs","title":"Example: Min-Hash Signature (MHS)","text":""},{"location":"sim_search/#lsh-example-constructing-database","title":"LSH Example: Constructing Database","text":""},{"location":"sim_search/#similarity-search-in-fingerprint-database","title":"Similarity Search in Fingerprint Database","text":""},{"location":"sim_search/#probability-of-detection","title":"Probability of Detection","text":"<pre><code>\"lsh_param\": {\n    \"ntbl\": 100,        # b: Number of hash tables  \n    \"nhash\": 4,         # r: Number of hash functions per table  \n    \"nvote\": 2,         # v: Number of votes  \n    \"nthread\": 8,       # Number of threads for parallel processing  \n    \"npart\": 1,         # Number of partitions for the database  \n    \"repeat\": 5         # Near-repeat exclusion parameter (samples)  \n},\n</code></pre>  Jaccard Similarity"},{"location":"sim_search/#lsh-parameter-guidance","title":"LSH Parameter Guidance","text":"<ul> <li> <p><code>ntbl</code> (b): Number of hash tables</p> <ul> <li>100 is good default value</li> </ul> </li> <li> <p><code>nhash</code> (r): Number of hash functions per table  </p> <ul> <li>Most sensitive parameter; significant effect on detection performance </li> <li>Lower values: fewer missed detections, more false detections, longer runtime  </li> <li>Higher values: more missed detections, fewer false detections, shorter runtime  </li> <li>Suggested values (only possibilities are 1,2,3,4,5,6,7,8):  <ul> <li><code>nhash</code>=4 for shorter duration data sets (days \u2013 weeks)  </li> <li><code>nhash</code>=5 for longer data sets (months \u2013 year)  </li> <li><code>nhash</code>=6 for longest data sets (5-10 years)  </li> </ul> </li> </ul> </li> <li> <p><code>nvote</code> (v): Number of votes (pair of similar fingerprints must be in same hash bucket in at least v out of b hash tables)  </p> <ul> <li>Can use <code>nvote</code> as threshold for single station detection  </li> <li><code>nvote</code>=2 is good starting value; initially set low, can increase threshold later during network detection  </li> </ul> </li> <li> <p><code>repeat</code>: Near-repeat exclusion parameter  </p> <ul> <li>Avoid detecting any fingerprint with itself (or slight offset to itself), which is guaranteed to be similar  </li> <li>5 samples is good default value (Multiply by <code>dt_fp</code> to get value in seconds)  </li> </ul> </li> </ul> <p></p> The Jaccard similarity threshold (fast increasing part of the S-curve) increases with the increase of number of hash functions (r), number of votes (v) and the decrease of number of tables (b)"},{"location":"sim_search/#performance-impact-of-lsh-parameters","title":"Performance Impact of LSH Parameters","text":""},{"location":"sim_search/#performance-impact-of-lsh-parameters-explanation","title":"Performance Impact of LSH Parameters (Explanation)","text":"Larger nfuncs --&gt; more non-empty hash buckets Larger \u201cnfuncs\u201d --&gt; more non-empty hash buckets, but \u201clargest\u201d hash buckets are smaller (i.e. fingerprints are more \u201cspread out\u201d within hash table) --&gt; faster runtime for similarity search but lower detection threshold (fingerprints must have higher Jaccard similarity for hash collisions)."},{"location":"sim_search/#lsh-parameters-and-detection-results","title":"LSH Parameters and Detection Results","text":"<p>The sensitivity of the FAST detector depends on the combination of nfuncs and nvotes. The table below shows how the number of detections identified by multi-station FAST on the Iquique foreshock data set from Bergen &amp; Beroza (2018a) changes as the nfuncs and nvotes parameters are varied. The first row (highlighted in blue) gives the parameter values used in Bergen &amp; Beroza (2018a).  </p> <p> </p> <p>The size of the output (# of fingerprint-pairs, i.e. # non-zeros in sparse similarity matrix) of the FAST detector depends on the combination of nfuncs and nvotes.  </p> <p>Increasing nvotes decreases the output size by increasing the detection threshold, while increasing nfuncs decreases the output size by lowering the detection threshold. Even though the number of detections for (nfuncs 5, nvotes 3) is slightly larger than for (nfuncs 8, nvotes 1), the latter has an output size that is an order of magnitude larger \u2013 this is due to a higher chance of spurious hash collisions associated with requiring only a single \u201cvote\u201d or collision out of 100 hash tables. Table shows output size for FAST detection results in Iquique case study from Bergen &amp; Beroza (2018a).  </p> <p> </p> <p> </p> Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 5, nvotes: 3 <p> </p> Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 8, nvotes: 3 <p> </p> Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 8, nvotes: 1"},{"location":"sim_search/#lsh-parameter-guidance-performance-related","title":"LSH Parameter Guidance (Performance related)","text":"<ul> <li><code>ncores</code>: Number of processes for parallel processing    <ul> <li>For large continuous data sets (&gt;months): use as many as your machine allows  </li> <li>Runtime decreases inverse proportionally with the increase of number of threads  </li> </ul> </li> </ul> <ul> <li><code>num_partitions</code>: Number of partitions for LSH database  <ul> <li>LSH database can be enormous, especially for large continuous data sets  </li> <li>FAST is intended to run on Linux clusters with lots of memory (&gt; 64 GB); figure out how much memory is on your machine  <ul> <li>If data set is small (days-weeks), use <code>num_partitions</code>= 1 (entire database fit in memory)</li> <li>Use num_partitions &gt; 1 for larger data sets, so that each partition fits in memory  </li> </ul> </li> </ul> </li> </ul> # partitions <ul> <li><code>noise_freq</code>: (Occurrence filter) Frequency threshold above which fingerprints will be filtered out as correlated noise  <ul> <li>Consider turning on this filter if some of the stations/channels produce orders of magnitude more outputs or take significant longer than its counterparts  </li> <li>The slow down might be caused by the large number of matches generated from persistent background noise (see figure below as an example)  </li> </ul> </li> </ul> Example of correlated noise <ul> <li> <p>Increase <code>num_partitions</code> to capture correlated noise that only appear in short segments of the input data  </p> </li> <li> <p>Example parameters</p> <ul> <li>Input: 1 year of time series data<ul> <li><code>noise_freq</code>=0.01  </li> <li><code>num_partitions</code>=12  </li> <li>Filter out fingerprints that matches over 1% of other fingerprints in the current partition (partition length = 1 year / 12 = 1 month)  </li> </ul> </li> <li>Input: 1 month of time series data  <ul> <li><code>noise_freq</code>=0.005  </li> <li><code>num_partitions</code>=30  </li> <li>Filter out fingerprints that matches over 0.5% of other fingerprints in the current partition (partition length = 1 month / 30 = 1 day)  </li> </ul> </li> </ul> </li> <li> <p>Performance benefits  </p> <ul> <li>Can reduce the similarity search output size by orders of magnitude as well as improve runtime  </li> <li>Reduced output size further improves the postprocessing runtime  </li> </ul> </li> </ul>"},{"location":"sim_search/#fast-similarity-search-output-format","title":"FAST Similarity Search Output Format","text":"<ul> <li> <p>Naming convention for text output files  </p> <ul> <li>One file, regardless of npart: <code>candidate_pairs_${STATION}_${CHANNEL}_merged.txt</code> </li> <li>Example text file (output): <code>candidate_pairs_CDY_EHZ_merged.txt</code> </li> </ul> </li> <li> <p>Content of output file:  </p> <ul> <li>list of pairs of similar fingerprints and their similarity, sorted in increasing dt order: dt = index1-index2, index1, sim </li> <li>index1 is index of first fingerprint (according to global index)  </li> <li>index2 is index of second fingerprint (according to global index)  </li> <li>sim is \u201cFAST similarity\u201d: Number of hash tables (out of b=ntbl) containing fingerprints index1 and index2 in same bucket; should be \u2265 (v=nvote). Note: not normalized as the fraction divided by b.  </li> </ul> </li> <li> <p>To get fingerprint times  </p> <ul> <li>get global start time t0 from global_idx_stats.txt, fingerprint lag dt_fp in seconds  </li> <li>time1 = t0 + dt_fp * index1, time2 = t0 + dt_fp * index2</li> </ul> </li> </ul>"},{"location":"tanzania_dataset/","title":"0.3 Tanzania, August 2016","text":"<p>Temporary dense deployment of seismic stations in Tanzania to identify previously unknown faults and infer their dimensions. 1 month continuous data (2016-07-31 to 2016-08-31), at 5 stations, 15 channels (3 components per station), provided by Laura Parisi of King Abdullah University of Science and Technology (KAUST). The stations are located about 10 km apart, at the base of a volcanic caldera called Ngorongoro Crater. For all 15 channels, we applied the following preprocessing: 4-12 Hz bandpass filter, then decimated to 25 Hz (factor of 8, from original 200 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise (only on station CES04).  </p> <p>Table S4: FAST input parameters for Tanzania earthquake detection, applied to each component at all 5 stations. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989.  </p> <p> </p> <p>Table S5: Network detection input parameters for Tanzania earthquakes at 5 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HNE,HNN,HNZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6.  </p> <p> </p> <p>Table S6: Final thresholds for Tanzania earthquakes, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.  </p> <p> </p> <p> </p> Figure 4: Tanzania earthquake detections from 2016-07-31 to 2016-08-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S6). FAST detected a total of 1,156 earthquakes during this month. Some false positive detections had to be removed manually, especially detections on only 2 out of 5 stations."},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#example-data-hector-mine-foreshocks","title":"Example Data: Hector Mine Foreshocks","text":"<p>Decimated filtered waveform data (20 Hz sampling rate) to use for FAST: <code>data/waveforms${STATION}/Deci5*</code> Original unfiltered waveform data (20 to 100 Hz sampling rate) to use for phase picking: <code>data/waveforms${STATION}/19991015*</code></p>"},{"location":"tutorial/#file-structure-overview","title":"File Structure Overview","text":""},{"location":"tutorial/#code","title":"Code","text":"<pre><code>fingerprint/          # Fingerprint\nsimsearch/            # Similarity Search\npostprocessing/       # Postprocessing\nutils/                # Utility Functions\n    preprocess/       \n    network/          \n    events/           \n    run_fp.py         \n    run_simsearch.py\n</code></pre>"},{"location":"tutorial/#configuration-and-parameters","title":"Configuration and Parameters","text":"<pre><code>parameters/            \n    fingerprint/       \n    simsearch/         \n    postprocess/\n</code></pre>"},{"location":"tutorial/#data","title":"Data","text":"<pre><code>data/\n    waveforms${STATION}/\n        Deci5*${STATION}*.sac\n        19991015*${STATION}*.sac\n</code></pre>"},{"location":"tutorial/#feature-extraction","title":"Feature Extraction","text":""},{"location":"tutorial/#generate-fingerprints","title":"Generate Fingerprints","text":"<ul> <li>Create fingerprints for each of the 9 channels (7 stations) + global index, using wrapper</li> </ul> <pre><code>~/quake_tutorial$ python run_fp.py -c config.json\n</code></pre> <ul> <li>Alternatively, to fingerprint a specific station, call the fingerprint script with the corresponding fingerprint parameter file:</li> </ul> <pre><code>~/quake_tutorial$ cd fingerprint/\n~/quake_tutorial/fingerprint$ python gen_fp.py ../parameters/fingerprint/fp_input_CI_CDY_EHZ.json\n</code></pre>"},{"location":"tutorial/#global-index","title":"Global Index","text":"<p>Note</p> <p>Global index is already called by run_fp.py wrapper  </p> <ul> <li>Complete this step only after you have finished computing fingerprints for every component and station you want to use for detection.  </li> </ul> <pre><code>$ python global_index.py global indices.json\n</code></pre> <ul> <li><code>global_index.py</code> in <code>fingerprint/</code></li> <li><code>global_indices.json</code> in <code>parameters/fingerprint/</code> </li> <li>Continuous data start/end times may be different, and time gaps may happen at different times, at different components and stations.  </li> <li>Global index: consistent way to refer to times of fingerprints at different components and stations.  </li> </ul>"},{"location":"tutorial/#similarity-search","title":"Similarity Search","text":""},{"location":"tutorial/#search-for-similar-earthquake-pairs","title":"Search for Similar Earthquake Pairs","text":"<ul> <li>Compile and build C++ similarity search code.</li> </ul> <pre><code>~/quake_tutorial$ cd simsearch/\n~/quake_tutorial$ cmake .\n~/quake_tutorial$ make\n</code></pre> <ul> <li>Similarity search for each of the 9 channels (7 stations), using wrapper  </li> </ul> <pre><code>~/quake_tutorial/simsearch$ cd ..\n~/quake_tutorial$ python run_simsearch.py -c config.json\n</code></pre> <ul> <li>Alternatively, to use similarity search for a specific station, call the similarity search script with the corresponding similarity search parameter file:</li> </ul> <pre><code>~/quake_tutorial$ cd simsearch/\n~/quake_tutorial$ cp ../parameters/simsearch/simsearch_input_HectorMine.sh .\n~/quake_tutorial$ ./simsearch_input_HectorMine.sh\n</code></pre>"},{"location":"tutorial/#fast-similarity-search-output-1-channel","title":"FAST Similarity Search Output (1 Channel)","text":"<p><code>data/waveforms${STATION}/fingerprints</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2014 MinHash Signatures (can delete these later) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2022 <code>mh_${STATION}_${CHANNEL}_${nhash}.bin</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2022 Example: <code>mh_CDY_EHZ_4.bin</code> </p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2014 Binary files with similarity search output (npart files, one per partition, with first and last fingerprint index for the partition in filename): \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2022 <code>candidate_pairs_${STATION}_${CHANNEL}_${nhash},${ntbl}(${FIRST_FP_INDEX},${LAST_FP_INDEX})</code>  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2022 Example: <code>andiate_pairs_CDY_EHZ_4,2(0,74793)</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2022 For efficiency, the output is binary format; need parsing to convert similarity search \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0output to text files</p>"},{"location":"tutorial/#parse-fast-similarity-search-output-binary-text-file","title":"Parse FAST Similarity Search Output: [Binary --&gt; Text File]","text":"<ul> <li> <p>Use the wrapper script to parse all 9 channels (7 stations) <pre><code>~/quake_tutorial$ cd postprocessing\n~/quake_tutorial/postprocessing$ cp ../parameters/postprocess/*.sh .\n~/quake_tutorial/postprocessing$ ./output_HectorMine_pairs.sh\n</code></pre></p> </li> <li> <p>Parse a Specific Channel <pre><code>python parse_results.py \u2013d &lt;folder_with_binary_sim_search_files&gt; -p &lt;sim_search_filename_prefix&gt; -i &lt;global_index_file&gt;\n</code></pre></p> </li> <li> <p>Example input file: <code>candidate_pairs_CDY_EHZ_4,2(0,74793)</code> </p> </li> <li>Example command: <pre><code>$ python parse_results.py \u2013d ../data/waveformsCDY/fingerprints/ candidate_pairs_CDY_EHZ \u2013i ../data/global_indices/CDY_EHZ_idx_mapping.txt\n</code></pre></li> </ul>"},{"location":"tutorial/#postprocessing","title":"Postprocessing","text":""},{"location":"tutorial/#postprocess-combine-fast-similarity-search-output-3-components-1-station","title":"Postprocess: Combine FAST Similarity Search Output (3 Components @ 1 Station)","text":"<ul> <li> <p>Combine similarity matrix from all components in each station, and copy outputs to <code>../data/inputs_network/</code> using wrapper script:  </p> <ul> <li><code>~/quake_tutorial/postprocessing$ cp ../parameters/postprocess/*.sh .</code> </li> <li><code>~/quake_tutorial/postprocessing$ ./combine_HectorMine_pairs.sh</code> </li> </ul> </li> <li> <p>Alternatively, to combine outputs (add \u201cFAST similarity\u201d for same fingerprint pair (index1, index2) ) from a specific station:  </p> <ul> <li><code>$ python parse_results.py \u2013d &lt;folder_with_text_sim_search_files&gt; -p &lt;text_sim_search_file_prefix&gt; --sort true \u2013parse false \u2013c true \u2013t &lt;threshold&gt;</code> </li> <li> <p>Example: <code>$ python parse_results.py \u2013d ../data/inputs_network/ -p candidate_pairs_HEC --sort true \u2013parse false \u2013c true \u2013t 6</code> </p> <ul> <li>Adds FAST similarity for same fingerprint pairs on HEC components: <code>candidate_pairs_HEC_BHE_merged.txt</code>, <code>candidate_pairs_HEC_BHN_merged.txt</code>, <code>candidate_pairs_HEC_BHZ_merged.txt</code> </li> <li>Output (one file per station): <code>candidate_pairs_HEC_combined.txt</code> </li> </ul> <p>Warning</p> <p>By default, the *merged.txt files for all 3 components are deleted after combining! Copy them before this step if you want to keep them.</p> </li> <li> <p>Usually set threshold=number of components * v, where v=nvote at a single component  </p> <ul> <li>The threshold helps filter out matches generated from noise, since we require either strong matches at a single component, or weak matches at multiple components</li> <li>May want to set threshold slightly lower (e.g., 2*v) if the output size is too small after combining</li> </ul> </li> </ul> </li> </ul>"},{"location":"tutorial/#postprocess-weight-stations-equally","title":"Postprocess: Weight Stations Equally","text":"<ul> <li> <p>\u2018Equalize\u2019 across network: weighting stations with different number of components equally</p> <ul> <li>Hector Mine example: one 3-component station (HEC) with similarity threshold at 6 votes, and 6 1-component stations with similarity threshold at 2 votes.</li> <li>Want to weight each station equally, so multiply similarity in each 1-component station by 3<ul> <li><code>$ awk \u2018{print$1,$2,3*$3}\u2019 candidate_pairs_CDY_EHZ_merged.txt &gt; candidate_pairs_CDY_combined.txt</code></li> </ul> </li> </ul> </li> <li> <p>Another option: use only part of the data (e.g. vertical component at each station)</p> </li> </ul> <p></p>"},{"location":"tutorial/#postprocess-network-detection","title":"Postprocess: Network Detection","text":"<ul> <li>Run network detection (combine FAST results from all 7 stations):  <ul> <li><code>~/quake_tutorial/postprocessing$ cp ../parameters/network/* .</code> </li> <li><code>~/quake_tutorial/postprocessing$ python scr_run_network_det.py 7sta_2stathresh_network_params.json</code> </li> </ul> </li> </ul> <p>Input file: <code>7sta_2stathresh_network_params.json</code> </p> <pre><code>\"io\": {\n    \"channel_vars\": [\"CDY\", \"CPM\", \"GTM\", \"HEC\", \"RMM\", \"RMR\", \"TPC\"],  # Station names\n    \"fname_template\": \"candidate_pairs_%s_combined.txt\",                # Input file (to fill w/station name) \n    \"base_dir\": \u201d../data/\",                                             # Base directory\n    \"data_folder\": \"inputs_network/\",                                   # Input file directory\n    \"out_folder\": \"network_detection/\"                                  # Output file directory\n}\n</code></pre>"},{"location":"tutorial/#network-detection-outputs","title":"Network Detection Outputs","text":"<ul> <li>Network Detection Output (text file with labeled columns)<ul> <li>Example (ranked in descending order of \u2018peaksum\u2019): <code>7sta_2stathresh_detlist_rank_by_peaksum.txt</code> </li> <li>First (num_sta=number of stations) columns: starting fingerprint index at each station (time information)  <ul> <li>Outputs \u201cnan\u201d if not observed at a particular station</li> </ul> </li> <li><code>dL</code>: Maximum length (samples) along diagonal, over all event-pairs containing this event  </li> <li><code>nevents</code>: Number of other events \u2018linked\u2019 to (similar to) this event</li> <li><code>nsta</code>: Number of stations over which other events are similar to this event</li> <li><code>tot_ndets</code>: Total number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations</li> <li><code>max_ndets</code>: Maximum number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations</li> <li><code>tot_vol</code>: Total sum (or \u2018volume\u2019) of all similarity values (added over all stations), over all event-pairs containing this event</li> <li><code>max_vol:</code> Maximum sum (or \u2018volume\u2019) of all similarity values (added over all stations), over all event-pairs containing this event</li> <li><code>max_peaksum</code>: Maximum similarity value (added over all stations), over all event-pairs containing this event</li> </ul> </li> </ul>"},{"location":"tutorial/#example-custom-scripts-to-clean-up-and-visualize-network-detection-results","title":"Example Custom Scripts to Clean up and Visualize Network Detection Results","text":"<ul> <li>Depending on the parameters, network detection output text file might still have duplicate events</li> <li> <p>We provide some example post-processing scripts to remove these duplicate events and come up with a final list of event detections</p> <ul> <li><code>cp ../utils/network/* .</code></li> </ul> <p>Note</p> <p>These have not been fully tested. You may want to write your own instead! Need to modify input/output parameters within each script. 4 scripts: outputs of each script are inputs to the next script.</p> </li> <li> <p><code>~/quake_tutorial/postprocessing$ python arrange_network_detection_results.py</code> </p> <ol> <li>Save only start and end fingerprint indices for each event (Firstnum_stacolumns --&gt; 2 columns)</li> <li>Output 2 more columns at end<ol> <li><code>Num_sta</code>: number of stations that detected event</li> <li><code>Diff_ind</code>: Difference between first and last fingerprint index</li> </ol> </li> <li>Example output: <code>NetworkDetectionTimes_7sta_2stathresh_detlist_rank_by_peaksum.txt</code></li> </ol> </li> <li> <p><code>~/quake_tutorial/postprocessing$ ./remove_duplicates_after_network.sh</code> </p> <ol> <li>Remove events with duplicate start fingerprint index (keep events with highest num_sta then peaksum)</li> <li>Example output: <code>uniquestart_sorted_no_duplicates.txt</code></li> </ol> </li> <li> <p><code>~/quake_tutorial/postprocessing$ python delete_overlap_network_detections.py</code> </p> <ol> <li>Remove events with overlapping times: where start time of one event is before end time of another event</li> <li>Example output: <code>7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt</code></li> </ol> </li> <li> <p><code>~/quake_tutorial/postprocessing$ ./final_network_sort_nsta_peaksum.sh</code> </p> <ol> <li>Sort events in descending order of num_sta (number of stations that detected event), then peaksum (maximum similarity for this event)</li> <li>Should no longer have duplicate events</li> <li>Example output: <code>sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt</code></li> </ol> </li> </ul>"},{"location":"tutorial/#final-thresholds-visualmanual-inspection","title":"Final Thresholds: Visual/Manual Inspection","text":"<p>Now we have a list of detections \u2014 but are they actually earthquakes? We need to plot and visually inspect them.  </p> <p>Example script, view first 100 events: <pre><code>~/quake_tutorial/utils/events$ python PARTIALplot_hector_detected_waveforms.py 0 100\n</code></pre></p> <ul> <li>Input finger indices from <code>sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt</code> </li> <li>Need global start time (t0) from global_idx_stats.txt, dt_fp in seconds  </li> <li>Here t0 = UTCDateTime('1999-10-15T13:00:00.676000')  </li> <li>Event time = t0 + dt_fp * (start finger print index)  </li> <li>Cut short time window around event waveform in filtered data, plot across all stations, save image to png file with names ordered in descending order of num_sta, peaksum \u2013 does it look like an earthquake?  </li> </ul> <p>Set final thresholds for num_sta, peaksum  </p> <ul> <li>Example Output (first 50 events):</li> </ul> <pre><code>EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre> <p>Additional post-processing scripts to remove false positive detections?  </p>"},{"location":"tutorial/#final-event-detection-list","title":"Final Event Detection List","text":"<p>Example Script: <pre><code>~/quake_tutorial/utils/events$ python output_final_detection_list.py\n</code></pre></p> <p>Example Input: <pre><code>EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt\n</code></pre></p> <p>Example Output: <pre><code>FINAL_Detection_List_HectorMine_7sta_2stathresh.txt\n</code></pre></p> <ul> <li>Column 1: Event ID  </li> <li>Column 2: YYYY-MM-DDTHH:MM:SS.SSSS for event detection time. This is an approximate arrival time for the event (NOT origin time)  </li> <li>Column 3: Event detection time (seconds) since the start time for the first fingerprint, which for this data set is UTCDateTime('1999-10-15T13:00:00.676000')  </li> <li>Column 4: First fingerprint index (integer) for this event. Multiply by dt_fp = 1 second to get the time in column 2. Columns 1, 2, 3 basically represent the same information.  </li> <li>Column 5: Last fingerprint index (integer) for this event from the network-detection</li> <li>Column 6: Fingerprint index duration; column5 = column4-column3. Some sense of event duration</li> <li>Column 7: Number of stations at which the event was similar enough for a detection, the higher the better (nsta_thresh = 2)  </li> <li>Column 8: Peak sum of similarity for this event over all stations where it was detected, the higher the better (more similar to some other event).</li> <li>Detection list is ordered in descending order of number of stations (Column 6), then in descending order of peaksum similarity (Column 7).  </li> </ul> <p>Further processing is required for P/S phase picking and location:  </p> <ul> <li>Cut SAC files  </li> <li>Pick phases (automatic or manual)  </li> <li>Locate earthquakes  </li> <li>Compute magnitudes  </li> </ul> <p>Info</p> <ul> <li>The following tutorials are not a part of FAST, but are optional next steps to take for phase picking with SeisBench, earthquake location with HYPOINVERSE, and mapping/visualization with PyGMT.</li> <li>The same commands below should run within the Docker container, but replace the path <code>~/FAST/</code> with <code>root@555d364b63d7:/app/FAST/</code></li> </ul>"},{"location":"tutorial/#phase-picking","title":"Phase Picking","text":""},{"location":"tutorial/#cut-sac-files","title":"Cut SAC Files","text":"<ul> <li>Cut short event waveform files in SAC format from the continuous seismic data at all stations, based on the detection results from FAST.</li> <li>Cut from the original unfiltered continuous seismic data at full sampling rate (usually 100 sps), not the decimated filtered continuous seismic data used to run FAST.</li> <li>In this example, the event waveform time windows are 180 seconds long, 60 seconds before detection time, 120 seconds after detection time.</li> </ul> <pre><code>(eq_fast) ~/FAST/utils/events$ python cut_event_files.py\n</code></pre> <ul> <li>Check for cut files in:  </li> </ul> <pre><code>(eq_fast) ~/FAST/data/event_ids\n</code></pre> <ul> <li>Example:  </li> </ul>"},{"location":"tutorial/#install-seisbench","title":"Install SeisBench","text":"<pre><code>(eq_fast) ~/FAST/utils/events$ cd ../..\n(eq_fast) ~/FAST$ pip install seisbench\n</code></pre>"},{"location":"tutorial/#pick-phases-automatically","title":"Pick Phases (automatically)","text":"<ul> <li>Run SeisBench script for all events and all stations. This can take a few minutes to finish running.</li> </ul> <pre><code>(eq_fast) ~/FAST$ cd utils/picking\n(eq_fast) ~/FAST/utils/picking$ python run_seisbench.py\n</code></pre> <ul> <li>Annotated plots are found in:  </li> </ul> <pre><code>(eq_fast) ~/FAST/data/seisbench_picks/\n</code></pre> <ul> <li>Example annotated plot from event 00000000:  </li> </ul> <p>Output saved in: <pre><code>(eq_fast) ~/FAST/data/seisbench_picks/event_picks.json\n</code></pre></p> <p>Example output:  </p> <p></p> <ul> <li>\"peak_time\": Arrival time of pick</li> <li>\"peak_value\": Probability of pick</li> </ul>"},{"location":"tutorial/#earthquake-location","title":"Earthquake Location","text":"<p>The output from <code>run_seisbench.py</code> in the <code>event_picks.json</code> file contains the information needed to locate the detected earthquakes from the FAST final detection list. We use HYPOINVERSE to locate earthquakes from the picks found with <code>run_seisbench.py</code>.  </p> <p>HYPOINVERSE is the standard location program supplied with the Earthworm seismic acquisition and processing system (AQMS). Read more about it here.  </p>"},{"location":"tutorial/#formatting-input-data-for-hypoinverse","title":"Formatting input data for HYPOINVERSE","text":"<p>To begin earthquake location run the following to format the phase picks for HYPOINVERSE:  </p> <pre><code>(eq_fast) ~/FAST/utils/picking$ cd ../location/\n(eq_fast) ~/FAST/utils/location$ python SeisBench2hypoinverse.py\n</code></pre> <p>Output: <pre><code>~/FAST/data/location_hypoinverse/EQT_19991015_test.txt\n</code></pre></p> <p>The script <code>SeisBench2hypoinverse.py</code> will also copy the following files from <code>~/FAST/utils/location/</code> to the directory <code>~/FAST/data/location_hypoinverse/</code> where we will run HYPOINVERSE: <pre><code>   *   hadley.crh\n   *   locate_events.hyp\n</code></pre></p> <p>Get Hector Mine Station List as a json file: <pre><code>(eq_fast) ~/FAST/utils/location$ cd ../preprocess/\n(eq_fast) ~/FAST/utils/preprocess$ python get_station_list.py\n</code></pre></p> <p>Output: <pre><code>~/FAST/data/stations/station_list.json\n</code></pre></p> <p>Convert <code>station_list.json</code> to HYPOINVERSE station input format in <code>station_list.sta</code>: <pre><code>(eq_fast) ~/FAST/utils/preprocess$ cd ../location/\n(eq_fast) ~/FAST/utils/location$ python output_station_file.py\n</code></pre></p> <p>Output: <pre><code>~/FAST/data/location_hypoinverse/station_list.sta\n</code></pre></p>"},{"location":"tutorial/#install-and-run-hypoinverse","title":"Install and Run HYPOINVERSE","text":"<p>Check that GFortran is installed, since it is required to compile the HYPOINVERSE program from source: <pre><code>(eq_fast) ~/FAST$ gfortran --version\n</code></pre></p> <p>Example expected output: GNU Fortran (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0 </p> <p>If GFortran is not installed, run: <pre><code>(eq_fast) ~/FAST$ apt-get update &amp;&amp; apt-get upgrade\n(eq_fast) ~/FAST$ apt-get install gfortran\n</code></pre></p> <p>Download HYPOINVERSE here, expand the <code>hyp1.40.tar</code> file, move the resulting <code>hyp1.40/</code> directory to <code>~/FAST/utils/location/hyp1.40/</code>. This can be done with the following commands: <pre><code>(eq_fast) ~/FAST/utils/location$ wget -c https://escweb.wr.usgs.gov/content/software/HYPOINVERSE/hyp1.40.tar\n(eq_fast) ~/FAST/utils/location$ mkdir hyp1.40\n(eq_fast) ~/FAST/utils/location$ cd hyp1.40\n(eq_fast) ~/FAST/utils/location/hyp1.40$ tar -xvf ../hyp1.40.tar\n(eq_fast) ~/FAST/utils/location/hyp1.40$ ls -l\ndrwxr-xr-x  4 10003  124   128 Sep 10  2014 doc\n-rw-r--r--  1 root  root 77392 Sep 10  2014 hyp1.40-release-notes.pdf\n-rw-r--r--  1 root  root  3258 Sep 10  2014 hyp1.40-release-notes.txt\ndrwxr-xr-x 54 10003  124  1728 Sep 10  2014 source\ndrwxr-xr-x 13 10003  124   416 Aug 26  2014 testone\n</code></pre></p> <p>Before compiling HYPOINVERSE, we need to make changes to <code>makefile</code> in <code>~/FAST/utils/location/hyp1.40/source/</code>: <pre><code>(eq_fast) ~/FAST/utils/location/hyp1.40$ cd source\n(eq_fast) ~/FAST/utils/location/hyp1.40/source$ sed -i '/calnet/d' makefile\n(eq_fast) ~/FAST/utils/location/hyp1.40/source$ sed -i 's/g77/gfortran/g' makefile\n</code></pre></p> <ul> <li>Remove lines 16 and 230</li> </ul> <pre><code>cp hyp1.40 /home/calnet/klein/bin\n</code></pre> <pre><code>cp p2sdly /home/calnet/klein/bin\n</code></pre> <ul> <li>Find and replace: <code>g77</code> with <code>gfortran</code></li> </ul> <p>Check that HYPOINVERSE runs:</p> <ul> <li> <p>Compile HYPOINVERSE: <pre><code>(eq_fast) ~/FAST/utils/location/hyp1.40/source$ make\n</code></pre></p> </li> <li> <p>Make it executable: <pre><code>(eq_fast) ~/FAST/utils/location/hyp1.40/source$ chmod +x hyp1.40\n</code></pre></p> </li> <li> <p>Run HYPOINVERSE: <pre><code>(eq_fast) ~/FAST/utils/location/hyp1.40/source$ ./hyp1.40\n</code></pre></p> </li> <li> <p>Expected output: <pre><code>HYPOINVERSE 2000 STARTING\n6/2014 VERSION 1.40 (geoid depth possible)\n COMMAND?\n</code></pre></p> </li> </ul> <p>If you have this output, HYPOINVERSE is running correctly. Press ctrl-c to exit.</p>"},{"location":"tutorial/#run-hypoinverse","title":"Run HYPOINVERSE","text":"<p>Run HYPOINVERSE within the directory <code>~/FAST/data/location_hypoinverse/</code>: <pre><code>(eq_fast) ~/FAST/utils/location$ cd ../../data/location_hypoinverse/\n(eq_fast) ~/FAST/data/location_hypoinverse$ ../../utils/location/hyp1.40/source/hyp1.40\n</code></pre></p> <p>Use @locate_events.hyp as input: <pre><code>HYPOINVERSE 2000 STARTING\n6/2014 VERSION 1.40 (geoid depth possible)\n COMMAND? @locate_events.hyp\n</code></pre></p> <p>Expected output:  </p> <p>You should see output files called <code>locate_events.sum</code> and <code>locate_events.arc</code> in HYPOINVERSE Y2000 summary format, but these are difficult to read.</p> <p>Note</p> <p><code>locate_events.arc</code> has the event info, and phase pick info for each event. <code>locate_events.sum</code> has only the event info, no phase pick info.</p> <p>Use <code>output_hypoinverse_as_text.py</code> to output <code>locate_events.sum</code> in a more readable format to use for plotting and visualization.</p> <pre><code>(eq_fast) ~/FAST/data/location_hypoinverse$ cd ../../utils/location/\n(eq_fast) ~/FAST/utils/location$ python output_hypoinverse_as_text.py\n</code></pre>"},{"location":"tutorial/#plotting-earthquake-locations-with-pygmt","title":"Plotting Earthquake Locations with PyGMT","text":""},{"location":"tutorial/#install-pygmt","title":"Install PyGMT","text":"<p>IMPORTANT - PyGMT needs to be installed and run in a separate <code>pygmt</code> conda environment, since it is incompatible with the <code>eq_fast</code> conda environment.</p> <p>First, exit the <code>eq_fast</code> conda environment <pre><code>(eq_fast) ~/FAST/utils/location$ conda deactivate\n</code></pre></p> <p>Next, create the <code>pygmt</code> conda environment with its dependencies, as described in the PyGMT install page <pre><code>(base) ~/FAST/utils/location$ conda config --prepend channels conda-forge\n(base) ~/FAST/utils/location$ conda create --name pygmt python=3.9 numpy pandas xarray netcdf4 packaging gmt\n</code></pre></p> <p>Finally, enter the <code>pygmt</code> conda environment and install PyGMT <pre><code>(base) ~/FAST/utils/location$ conda activate pygmt\n(pygmt) ~/FAST/utils/location$ conda install pygmt\n</code></pre></p>"},{"location":"tutorial/#create-a-pygmt-map-of-earthquake-locations-and-seismic-stations","title":"Create a PyGMT map of earthquake locations and seismic stations","text":"<pre><code>(pygmt) ~/FAST/utils/location$ cd ../mapping/\n(pygmt) ~/FAST/utils/mapping$ python hypoinverse_to_pygmt.py\n</code></pre> <p>Figure saved as <code>pygmt_hectormine_map.png</code> in <code>~/FAST/data/mapping_pygmt/</code></p> <p>Map Output:  </p>"},{"location":"tutorial/#_1","title":"Tutorial","text":""},{"location":"wenchuan_dataset/","title":"0.7 SeismOlympics: Wenchuan Aftershocks","text":"<p>Info</p> <p>Alibaba Cloud and the China Earthquake Administration sponsored a \u201dSeismOlympics\u201d programming competition to detect aftershocks of the deadly May 12, 2008 Mw 7.9 Wenchuan, China, earthquake [Fang et al., 2017], similar to the Netflix Prize or the Kaggle data science competitions. Competitors from seismology, machine learning, signal processing, computer science, and other backgrounds developed algorithms that automatically detect and pick phases on aftershock waveforms while avoiding false positive detections. Performance was evaluated against phases picked by human analysts. This was a great opportunity to test how the FAST earthquake detection algorithm measured up against other methods. Other members of my team, all from Stanford Geophysics (Mostafa Mousavi, Yixiao Sheng, Weiqiang Zhu) used machine learning to pick phases and recognize false detections. We finished in 27th place in the first round of competition, and 16th place in the second round.  </p> <p> </p> Figure 11: Map of 15 stations in Wenchuan, China used for FAST detection of small earthquakes in 3 months of continuous data. The ComCat catalog had 1039 aftershocks (circles colored by depth, sized by relative magnitudes 3.2 \u2264 M \u2264 6.1) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.9 Wenchuan earthquake on 2008-05-12.  <p>After the competition, I applied FAST to detect earthquakes within the entire continuous data set provided in both rounds of competition. 3 months of seismic data: April 1-22, 2008 (foreshocks), July 1-August 31, 2008 (aftershocks), at 15 stations (Figure 11) with 3 components each, although some stations only have data for part of this time. For all 45 channels, I applied the following preprocessing: 1-20 Hz bandpass filter, then decimated to 50 Hz (factor of 2, from original 100 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise. FAST detected about 12,000 earthquakes; some of them are teleseismic because the 1-20 Hz filter includes lower frequencies.  </p> <p>Table S18: FAST input parameters for Wenchuan 2008 aftershock detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 3,612,972.  </p> <p> </p> <p>Table S19: Network detection input parameters for Wenchuan 2008 aftershock detection at 15 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6.  </p> <p> </p> <p>Table S20: Final thresholds for Wenchuan 2008 aftershock detection applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.  </p> <p> </p>"}]}